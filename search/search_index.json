{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"\ud83d\udccf FileSizeLib  A unified storage unit library for Python with cross-platform file size support"},{"location":"#what-is-filesizelib","title":"\ud83d\ude80 What is FileSizeLib?","text":"<p>FileSizeLib is a powerful and intuitive Python storage unit library that makes it easy to handle calculations, conversions, and operations with various storage sizes. Whether you're working with file sizes, network bandwidth, or storage capacity, FileSizeLib makes these tasks simple and elegant.</p>"},{"location":"#core-features","title":"\u2728 Core Features","text":"<ul> <li> <p> \ud83e\uddee Smart Arithmetic with Unit Preservation</p> <p>Same-unit operations preserve units (1 GB + 2 GB = 3 GB), different units convert automatically</p> <p> View arithmetic operations</p> </li> <li> <p> \ud83d\udcdd Flexible String Parsing</p> <p>Parse multiple string formats with case-insensitive support and various separators</p> <p> Learn string parsing</p> </li> <li> <p> \ud83d\udd17 Cross-Platform File Operations</p> <p>Get file and directory sizes using pathlib with platform-specific optimizations</p> <p> File operations guide</p> </li> <li> <p> \u26a1 Platform Optimizations</p> <p>Platform-specific performance optimizations for Windows, Linux, and macOS</p> <p> Platform support details</p> </li> <li> <p> \ud83d\udd12 Type Safety</p> <p>Complete type annotations for better IDE support and code safety</p> <p> API Reference</p> </li> <li> <p> \ud83c\udfaf Zero Dependencies</p> <p>Uses only Python standard library, no external dependencies required</p> <p> Quick Start</p> </li> </ul>"},{"location":"#quick-example","title":"\ud83c\udfaf Quick Example","text":"<pre><code>from filesizelib import Storage, StorageUnit, FileSizeLib\n\n# Create storage values (Storage and FileSizeLib are identical)\nfile_size = Storage(1.5, StorageUnit.GB)\nbackup_size = FileSizeLib.parse(\"2.5 GB\")  # FileSizeLib alias\n\n# Smart arithmetic - same units preserve unit!\nsame_unit_total = file_size + backup_size\nprint(f\"Same unit: {same_unit_total}\")  # Output: 4.0 GB\n\n# Configure decimal precision (eliminates scientific notation)\nStorage.set_decimal_precision(5)\nsmall_value = Storage(1.23456789e-5, StorageUnit.TB)\nprint(f\"Precise: {small_value}\")  # Output: 0.00001 TB (no scientific notation!)\n\n# Convenient conversion methods\nprint(f\"File size (MB): {file_size.convert_to_mb()}\")  # 1500.0 MB\nprint(f\"Backup size (GiB): {backup_size.convert_to_gib()}\")  # 2.33 GiB\n\n# File operations\ndir_size = Storage.get_size_from_path(\"/path/to/directory\")\nprint(f\"Directory size: {dir_size.auto_scale()}\")\n\n# Reset precision to default\nStorage.set_decimal_precision(20)\n</code></pre>"},{"location":"#supported-unit-types","title":"\ud83d\udee0\ufe0f Supported Unit Types","text":"<pre><code>graph TD\n    A[Storage Units] --&gt; B[Binary Units]\n    A --&gt; C[Decimal Units]\n    A --&gt; D[Bit Units]\n\n    B --&gt; B1[BYTES]\n    B --&gt; B2[KiB, MiB, GiB]\n    B --&gt; B3[TiB, PiB, EiB]\n    B --&gt; B4[ZiB, YiB]\n\n    C --&gt; C1[KB, MB, GB]\n    C --&gt; C2[TB, PB, EB]\n    C --&gt; C3[ZB, YB]\n\n    D --&gt; D1[BITS]\n    D --&gt; D2[KILOBITS]\n    D --&gt; D3[MEGABITS]\n    D --&gt; D4[GIGABITS]\n    D --&gt; D5[TERABITS]\n\n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#e8f5e8\n    style D fill:#fff3e0</code></pre>"},{"location":"#why-choose-filesizelib","title":"\ud83c\udf1f Why Choose FileSizeLib?","text":""},{"location":"#simple-to-use","title":"Simple to Use","text":"<p>FileSizeLib's API is designed to be intuitive and follows Python best practices. You can accomplish complex storage unit operations with minimal code.</p>"},{"location":"#performance-optimized","title":"Performance Optimized","text":"<p>Built-in platform-specific optimizations ensure optimal performance across different operating systems.</p>"},{"location":"#type-safe","title":"Type Safe","text":"<p>Complete type annotation support makes your code more reliable and provides better IDE support.</p>"},{"location":"#zero-dependencies","title":"Zero Dependencies","text":"<p>No third-party dependencies reduce project complexity and potential security risks.</p>"},{"location":"#architecture-overview","title":"\ud83d\udd04 Architecture Overview","text":"<pre><code>graph LR\n    A[User Code] --&gt; B[Storage Class]\n    B --&gt; C[StorageUnit Enum]\n    B --&gt; D[Arithmetic Ops]\n    B --&gt; E[Conversion Methods]\n    B --&gt; F[String Parsing]\n    B --&gt; G[File Operations]\n\n    G --&gt; H[PlatformStorage]\n    H --&gt; I[WindowsStorage]\n    H --&gt; J[LinuxStorage]\n    H --&gt; K[MacStorage]\n\n    style A fill:#e3f2fd\n    style B fill:#f3e5f5\n    style C fill:#e8f5e8\n    style D fill:#fff3e0\n    style E fill:#fce4ec\n    style F fill:#f1f8e9\n    style G fill:#e0f2f1\n    style H fill:#e8eaf6</code></pre>"},{"location":"#next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li> <p> Quick Start</p> <p>Learn FileSizeLib basics in 5 minutes</p> </li> <li> <p> User Guide</p> <p>Deep dive into all features and best practices</p> </li> <li> <p> API Reference</p> <p>Complete API documentation and method reference</p> </li> <li> <p> Examples</p> <p>Real-world scenarios and code examples</p> </li> </ul> <p>Start your FileSizeLib journey Install Now </p>"},{"location":"decimal_precision/","title":"Decimal Precision in filesizelib","text":""},{"location":"decimal_precision/#overview","title":"Overview","text":"<p>Starting from version 0.11.4, filesizelib implements exact decimal precision using Python's <code>Decimal</code> module. This eliminates floating-point precision errors that could occur with values that cannot be exactly represented in IEEE 754 floating-point format.</p>"},{"location":"decimal_precision/#problem-solved","title":"Problem Solved","text":""},{"location":"decimal_precision/#before-floating-point-issues","title":"Before (Floating-Point Issues)","text":"<pre><code>from filesizelib import FileSize\n\n# Floating-point precision errors\nprint(FileSize.parse('6.682 MB'))  # Output: 6.68200000000000038369 MB\n</code></pre>"},{"location":"decimal_precision/#after-exact-decimal-precision","title":"After (Exact Decimal Precision)","text":"<pre><code>from filesizelib import FileSize\n\n# Exact decimal precision\nprint(FileSize.parse('6.682 MB'))  # Output: 6.682 MB\n</code></pre>"},{"location":"decimal_precision/#key-features","title":"Key Features","text":""},{"location":"decimal_precision/#1-dual-property-access","title":"1. Dual Property Access","text":"<p>The Storage class provides two ways to access the stored value:</p> <ul> <li><code>value</code>: Returns <code>float</code> for backward compatibility</li> <li><code>decimal_value</code>: Returns <code>Decimal</code> for exact precision</li> </ul> <pre><code>from filesizelib import Storage, StorageUnit\nfrom decimal import Decimal\n\nstorage = Storage(\"6.682\", StorageUnit.MB)\n\n# Backward compatibility\nprint(storage.value)         # 6.682 (float)\nprint(type(storage.value))   # &lt;class 'float'&gt;\n\n# Exact precision\nprint(storage.decimal_value)         # Decimal('6.682')\nprint(type(storage.decimal_value))   # &lt;class 'decimal.Decimal'&gt;\n</code></pre>"},{"location":"decimal_precision/#2-exact-arithmetic-operations","title":"2. Exact Arithmetic Operations","text":"<p>All arithmetic operations maintain exact decimal precision:</p> <pre><code>a = Storage(\"1.1\", StorageUnit.GB)\nb = Storage(\"2.2\", StorageUnit.GB)\nresult = a + b\n\nprint(result)                    # 3.3 GB (exact)\nprint(result.decimal_value)      # Decimal('3.3')\n\n# Floating-point equivalent would show precision errors\nimport decimal\nfloat_result = 1.1 + 2.2\nprint(f\"{float_result:.17f}\")    # 3.30000000000000027\n</code></pre>"},{"location":"decimal_precision/#3-string-parsing-precision","title":"3. String Parsing Precision","text":"<p>String parsing maintains exact precision from input:</p> <pre><code># Various precision levels\ntest_cases = [\n    \"6.682 MB\",\n    \"1.234567890123456 GB\", \n    \"0.001 TB\",\n    \"9.999999999999999 KB\"\n]\n\nfor case in test_cases:\n    storage = Storage.parse(case)\n    print(f\"{case} -&gt; {storage}\")\n    # All values are displayed exactly as input\n</code></pre>"},{"location":"decimal_precision/#4-configurable-display-precision","title":"4. Configurable Display Precision","text":"<p>Control how many decimal places are shown in string representations:</p> <pre><code># Set precision for display\nStorage.set_decimal_precision(5)\n\nstorage = Storage(\"1.23456789012345\", StorageUnit.GB)\nprint(storage)  # 1.23457 GB (limited to 5 decimal places)\n\n# Reset to high precision\nStorage.set_decimal_precision(15)\nprint(storage)  # 1.234567890123450 GB\n</code></pre>"},{"location":"decimal_precision/#input-type-support","title":"Input Type Support","text":"<p>The Storage class accepts multiple input types:</p> <pre><code>from decimal import Decimal\n\n# Integer input\nstorage1 = Storage(1024, StorageUnit.BYTES)\n\n# Float input (converted to Decimal internally)\nstorage2 = Storage(1.5, StorageUnit.MB)\n\n# String input (parsed to Decimal)\nstorage3 = Storage(\"6.682 MB\")\n\n# Direct Decimal input (exact precision)\nstorage4 = Storage(Decimal(\"6.682\"), StorageUnit.MB)\n\n# All maintain exact precision in internal representation\n</code></pre>"},{"location":"decimal_precision/#backward-compatibility","title":"Backward Compatibility","text":""},{"location":"decimal_precision/#existing-code-continues-to-work","title":"Existing Code Continues to Work","text":"<pre><code># This code from version &lt; 0.11.4 still works identically\nstorage = Storage(1024, StorageUnit.BYTES)\nprint(storage.value)          # 1024.0 (float)\nprint(storage.convert_to_gb().value)  # 0.000001024 (float)\n\n# Arithmetic operations maintain compatibility\ntotal = storage + Storage(512, StorageUnit.BYTES)\nprint(total.value)            # 1536.0 (float)\n</code></pre>"},{"location":"decimal_precision/#new-precision-critical-code","title":"New Precision-Critical Code","text":"<pre><code># Use decimal_value for applications requiring exact precision\nstorage = Storage(\"6.682\", StorageUnit.MB)\n\n# Financial calculations, scientific measurements, etc.\nexact_bytes = storage.convert_to_bytes()  # Returns Decimal\nprint(type(exact_bytes))      # &lt;class 'decimal.Decimal'&gt;\n\n# For compatibility with float-expecting code\ncompatible_bytes = float(storage.convert_to_bytes())\nprint(type(compatible_bytes)) # &lt;class 'float'&gt;\n</code></pre>"},{"location":"decimal_precision/#method-return-types","title":"Method Return Types","text":""},{"location":"decimal_precision/#updated-return-types","title":"Updated Return Types","text":"<ul> <li><code>convert_to_bytes()</code>: Now returns <code>Decimal</code> (was <code>float</code>)</li> <li><code>parse_from_bytes()</code>: Now accepts <code>Decimal</code> input</li> </ul>"},{"location":"decimal_precision/#conversion-handling","title":"Conversion Handling","text":"<pre><code>storage = Storage(\"1.5\", StorageUnit.KB)\n\n# New: Returns Decimal\nbytes_decimal = storage.convert_to_bytes()\nprint(bytes_decimal)          # Decimal('1500')\n\n# For float compatibility\nbytes_float = float(storage.convert_to_bytes())\nprint(bytes_float)            # 1500.0\n\n# Type checking\nassert isinstance(bytes_decimal, Decimal)\nassert isinstance(bytes_float, float)\n</code></pre>"},{"location":"decimal_precision/#use-cases","title":"Use Cases","text":""},{"location":"decimal_precision/#when-to-use-decimal_value","title":"When to Use <code>decimal_value</code>","text":"<ul> <li>Financial calculations involving storage costs</li> <li>Scientific applications requiring exact measurements</li> <li>Data integrity verification</li> <li>Precise capacity planning</li> <li>Any context where rounding errors are unacceptable</li> </ul>"},{"location":"decimal_precision/#when-to-use-value","title":"When to Use <code>value</code>","text":"<ul> <li>Legacy code integration</li> <li>Performance-critical applications where small precision loss is acceptable</li> <li>Interfacing with APIs expecting float values</li> <li>General-purpose storage calculations</li> </ul>"},{"location":"decimal_precision/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Decimal operations are slightly slower than float operations</li> <li>Memory usage is marginally higher due to Decimal storage</li> <li>String formatting maintains high performance</li> <li>Conversion methods are optimized for common use cases</li> </ul>"},{"location":"decimal_precision/#migration-guide","title":"Migration Guide","text":""},{"location":"decimal_precision/#for-existing-users","title":"For Existing Users","text":"<p>No changes needed - all existing code continues to work identically.</p>"},{"location":"decimal_precision/#for-new-users-requiring-precision","title":"For New Users Requiring Precision","text":"<pre><code># Replace this pattern:\nstorage = Storage.parse(\"6.682 MB\")\nbytes_value = storage.convert_to_bytes()  # Now returns Decimal\n\n# With this for float compatibility:\nbytes_value = float(storage.convert_to_bytes())\n\n# Or embrace exact precision:\nexact_bytes = storage.convert_to_bytes()  # Keep as Decimal\nexact_decimal = storage.decimal_value     # Access exact value\n</code></pre>"},{"location":"decimal_precision/#examples","title":"Examples","text":""},{"location":"decimal_precision/#complete-precision-example","title":"Complete Precision Example","text":"<pre><code>from filesizelib import Storage, StorageUnit\nfrom decimal import Decimal\n\n# Create storage with exact precision\nstorage = Storage(\"6.682\", StorageUnit.MB)\n\nprint(\"String representation:\", storage)\nprint(\"Float value:\", storage.value)\nprint(\"Decimal value:\", storage.decimal_value)\nprint(\"Exact bytes:\", storage.convert_to_bytes())\nprint(\"Float bytes:\", float(storage.convert_to_bytes()))\n\n# Arithmetic maintains precision\ndoubled = storage * 2\nprint(\"Doubled:\", doubled)\nprint(\"Doubled decimal:\", doubled.decimal_value)\n\n# Output:\n# String representation: 6.682 MB\n# Float value: 6.682\n# Decimal value: Decimal('6.682')\n# Exact bytes: Decimal('6682000')\n# Float bytes: 6682000.0\n# Doubled: 13.364 MB\n# Doubled decimal: Decimal('13.364')\n</code></pre>"},{"location":"decimal_precision/#financial-calculation-example","title":"Financial Calculation Example","text":"<pre><code>from filesizelib import Storage\nfrom decimal import Decimal\n\n# Calculate storage costs with exact precision\nstorage_used = Storage(\"1.5\", StorageUnit.TB)\ncost_per_gb = Decimal(\"0.023\")  # $0.023 per GB per month\n\n# Convert to GB for cost calculation\ngb_used = storage_used.convert_to_gb().decimal_value\nmonthly_cost = gb_used * cost_per_gb\n\nprint(f\"Storage used: {storage_used}\")\nprint(f\"GB used: {gb_used}\")\nprint(f\"Monthly cost: ${monthly_cost}\")\n\n# Output:\n# Storage used: 1.5 TB\n# GB used: 1500\n# Monthly cost: 34.5\n</code></pre> <p>This implementation ensures that filesizelib can serve as a reliable foundation library for applications requiring exact decimal precision while maintaining full backward compatibility.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete API reference for all FileSizeLib classes and functions, automatically generated from source code.</p>"},{"location":"api/#core-components","title":"\ud83d\udcda Core Components","text":"<p>This page provides links to all the main components. Each component has its own detailed page:</p> <ul> <li>Storage Class - Main storage class with conversion and arithmetic operations</li> <li>StorageUnit Enum - Unit definitions and conversion factors  </li> <li>Platform Storage - Platform-specific optimized implementations</li> </ul>"},{"location":"api/#filesizelib-class-alias","title":"FileSizeLib Class Alias","text":"<p>The <code>FileSizeLib</code> class is an alias for the <code>Storage</code> class, providing identical functionality with a name that matches the package. Both classes are functionally identical and can be used interchangeably.</p> <p>All documentation is automatically generated from source code docstrings to ensure accuracy and completeness.</p>"},{"location":"api/platform-storage/","title":"Platform Storage","text":"<p>Platform-specific storage implementations for optimized file operations.</p>"},{"location":"api/platform-storage/#base-classes","title":"Base Classes","text":""},{"location":"api/platform-storage/#filesizelib.platform_storage.PlatformStorageBase","title":"<code>PlatformStorageBase(value: Union[int, float] = 0, unit: StorageUnit = StorageUnit.BYTES)</code>","text":"<p>               Bases: <code>Storage</code></p> <p>Base class for platform-specific storage implementations.</p> <p>This class extends the base Storage class and provides a foundation for platform-specific optimizations while maintaining compatibility with the base Storage interface.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[int, float]</code> <p>The numerical value of the storage (defaults to 0).</p> <code>0</code> <code>unit</code> <code>StorageUnit</code> <p>The unit of the storage value (defaults to BYTES).</p> <code>BYTES</code>"},{"location":"api/platform-storage/#filesizelib.platform_storage.PlatformStorageBase-functions","title":"Functions","text":""},{"location":"api/platform-storage/#filesizelib.platform_storage.PlatformStorageBase.get_platform_info","title":"<code>get_platform_info() -&gt; Dict[str, Any]</code>","text":"<p>Get platform-specific information.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing platform information.</p>"},{"location":"api/platform-storage/#platform-implementations","title":"Platform Implementations","text":""},{"location":"api/platform-storage/#filesizelib.platform_storage.WindowsStorage","title":"<code>WindowsStorage(value: Union[int, float] = 0, unit: StorageUnit = StorageUnit.BYTES)</code>","text":"<p>               Bases: <code>PlatformStorageBase</code></p> <p>Windows-specific storage implementation.</p> <p>This class provides Windows-optimized functionality for storage operations, including NTFS-specific features and Windows API optimizations where beneficial.</p> Features <ul> <li>Optimized file size retrieval using Windows APIs when available</li> <li>Support for Windows-specific file attributes</li> <li>NTFS stream and compression awareness</li> <li>Junction and symbolic link handling</li> </ul>"},{"location":"api/platform-storage/#filesizelib.platform_storage.WindowsStorage-functions","title":"Functions","text":""},{"location":"api/platform-storage/#filesizelib.platform_storage.WindowsStorage.get_size_from_path","title":"<code>get_size_from_path(path: Union[str, Path]) -&gt; Storage</code>","text":"<p>Get file or directory size with Windows-specific optimizations.</p> <p>This method provides enhanced file size calculation for Windows, including support for compressed files, sparse files, and  proper handling of junctions and symbolic links.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the file or directory.</p> required <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>Storage instance representing the total size.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the path does not exist.</p> <code>PermissionError</code> <p>If access to the path is denied.</p> <code>OSError</code> <p>If an OS-level error occurs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; win_storage = WindowsStorage()\n&gt;&gt;&gt; size = win_storage.get_size_from_path(\"C:\\Windows\\System32\")\n&gt;&gt;&gt; print(size.auto_scale())\n2.3 GIB\n</code></pre>"},{"location":"api/platform-storage/#filesizelib.platform_storage.WindowsStorage.get_platform_info","title":"<code>get_platform_info() -&gt; Dict[str, Any]</code>","text":"<p>Get Windows-specific platform information.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing Windows platform information.</p>"},{"location":"api/platform-storage/#filesizelib.platform_storage.LinuxStorage","title":"<code>LinuxStorage(value: Union[int, float] = 0, unit: StorageUnit = StorageUnit.BYTES)</code>","text":"<p>               Bases: <code>PlatformStorageBase</code></p> <p>Linux-specific storage implementation.</p> <p>This class provides Linux-optimized functionality for storage operations, including support for various Linux file systems and GNU/Linux specific tools and APIs.</p> Features <ul> <li>Optimized file size retrieval using Linux tools (du, find)</li> <li>Support for Linux-specific file attributes</li> <li>Symbolic link and mount point awareness</li> <li>File system type detection and optimization</li> </ul>"},{"location":"api/platform-storage/#filesizelib.platform_storage.LinuxStorage-functions","title":"Functions","text":""},{"location":"api/platform-storage/#filesizelib.platform_storage.LinuxStorage.get_size_from_path","title":"<code>get_size_from_path(path: Union[str, Path]) -&gt; Storage</code>","text":"<p>Get file or directory size with Linux-specific optimizations.</p> <p>This method provides enhanced file size calculation for Linux, including optimized directory traversal and proper handling of symbolic links, mount points, and special files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the file or directory.</p> required <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>Storage instance representing the total size.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the path does not exist.</p> <code>PermissionError</code> <p>If access to the path is denied.</p> <code>OSError</code> <p>If an OS-level error occurs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; linux_storage = LinuxStorage()\n&gt;&gt;&gt; size = linux_storage.get_size_from_path(\"/usr/lib\")\n&gt;&gt;&gt; print(size.auto_scale())\n1.8 GIB\n</code></pre>"},{"location":"api/platform-storage/#filesizelib.platform_storage.LinuxStorage.get_platform_info","title":"<code>get_platform_info() -&gt; Dict[str, Any]</code>","text":"<p>Get Linux-specific platform information.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing Linux platform information.</p>"},{"location":"api/platform-storage/#filesizelib.platform_storage.MacStorage","title":"<code>MacStorage(value: Union[int, float] = 0, unit: StorageUnit = StorageUnit.BYTES)</code>","text":"<p>               Bases: <code>PlatformStorageBase</code></p> <p>macOS-specific storage implementation.</p> <p>This class provides macOS-optimized functionality for storage operations, including support for HFS+/APFS specific features and macOS APIs.</p> Features <ul> <li>Optimized file size retrieval using macOS tools</li> <li>Support for macOS-specific file attributes (resource forks, extended attributes)</li> <li>APFS snapshot and clone awareness</li> <li>Spotlight integration for metadata</li> </ul>"},{"location":"api/platform-storage/#filesizelib.platform_storage.MacStorage-functions","title":"Functions","text":""},{"location":"api/platform-storage/#filesizelib.platform_storage.MacStorage.get_size_from_path","title":"<code>get_size_from_path(path: Union[str, Path]) -&gt; Storage</code>","text":"<p>Get file or directory size with macOS-specific optimizations.</p> <p>This method provides enhanced file size calculation for macOS, including proper handling of resource forks, extended attributes, and APFS-specific features.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the file or directory.</p> required <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>Storage instance representing the total size.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the path does not exist.</p> <code>PermissionError</code> <p>If access to the path is denied.</p> <code>OSError</code> <p>If an OS-level error occurs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mac_storage = MacStorage()\n&gt;&gt;&gt; size = mac_storage.get_size_from_path(\"/Applications\")\n&gt;&gt;&gt; print(size.auto_scale())\n15.7 GIB\n</code></pre>"},{"location":"api/platform-storage/#filesizelib.platform_storage.MacStorage.get_platform_info","title":"<code>get_platform_info() -&gt; Dict[str, Any]</code>","text":"<p>Get macOS-specific platform information.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing macOS platform information.</p>"},{"location":"api/storage-unit/","title":"StorageUnit Enum","text":""},{"location":"api/storage-unit/#filesizelib.storage_unit.StorageUnit","title":"<code>StorageUnit</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of storage units with their byte conversion factors.</p> <p>This enum defines both binary (base 1024) and decimal (base 1000)  storage units commonly used in computing and storage devices.</p> <p>Binary units (powers of 1024):     - BYTES, KIB, MIB, GIB, TIB, PIB, EIB, ZIB, YIB</p> <p>Decimal units (powers of 1000):     - KB, MB, GB, TB, PB, EB, ZB, YB</p> Bit units <ul> <li>BITS, KILOBITS, MEGABITS, GIGABITS, TERABITS</li> </ul> <p>Each enum value represents the number of bytes in one unit.</p>"},{"location":"api/storage-unit/#filesizelib.storage_unit.StorageUnit-functions","title":"Functions","text":""},{"location":"api/storage-unit/#filesizelib.storage_unit.StorageUnit.get_unit_aliases","title":"<code>get_unit_aliases() -&gt; Dict[str, StorageUnit]</code>  <code>classmethod</code>","text":"<p>Get a mapping of unit name aliases to StorageUnit enum values.</p> <p>This mapping supports case-insensitive parsing of unit names including common abbreviations and alternative spellings.</p> <p>Returns:</p> Type Description <code>Dict[str, StorageUnit]</code> <p>Dict[str, StorageUnit]: Mapping of lowercase unit names to enum values.</p>"},{"location":"api/storage-unit/#filesizelib.storage_unit.StorageUnit.get_binary_units","title":"<code>get_binary_units() -&gt; Set[StorageUnit]</code>  <code>classmethod</code>","text":"<p>Get a set of binary storage units (powers of 1024).</p> <p>Returns:</p> Type Description <code>Set[StorageUnit]</code> <p>Set[StorageUnit]: Set of binary storage units.</p>"},{"location":"api/storage-unit/#filesizelib.storage_unit.StorageUnit.get_decimal_units","title":"<code>get_decimal_units() -&gt; Set[StorageUnit]</code>  <code>classmethod</code>","text":"<p>Get a set of decimal storage units (powers of 1000).</p> <p>Returns:</p> Type Description <code>Set[StorageUnit]</code> <p>Set[StorageUnit]: Set of decimal storage units.</p>"},{"location":"api/storage-unit/#filesizelib.storage_unit.StorageUnit.get_bit_units","title":"<code>get_bit_units() -&gt; Set[StorageUnit]</code>  <code>classmethod</code>","text":"<p>Get a set of bit-based storage units.</p> <p>Returns:</p> Type Description <code>Set[StorageUnit]</code> <p>Set[StorageUnit]: Set of bit storage units.</p>"},{"location":"api/storage-unit/#filesizelib.storage_unit.StorageUnit.get_special_units","title":"<code>get_special_units() -&gt; Set[StorageUnit]</code>  <code>classmethod</code>","text":"<p>Get a set of special storage units (e.g., AUTO).</p> <p>Returns:</p> Type Description <code>Set[StorageUnit]</code> <p>Set[StorageUnit]: Set of special storage units.</p>"},{"location":"api/storage-unit/#filesizelib.storage_unit.StorageUnit.is_binary","title":"<code>is_binary() -&gt; bool</code>","text":"<p>Check if this unit is a binary unit (power of 1024).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a binary unit, False otherwise.</p>"},{"location":"api/storage-unit/#filesizelib.storage_unit.StorageUnit.is_decimal","title":"<code>is_decimal() -&gt; bool</code>","text":"<p>Check if this unit is a decimal unit (power of 1000).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a decimal unit, False otherwise.</p>"},{"location":"api/storage-unit/#filesizelib.storage_unit.StorageUnit.is_bit_unit","title":"<code>is_bit_unit() -&gt; bool</code>","text":"<p>Check if this unit is a bit-based unit.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a bit unit, False otherwise.</p>"},{"location":"api/storage/","title":"Storage Class","text":""},{"location":"api/storage/#filesizelib.storage.Storage","title":"<code>Storage(value: Union[int, float, str, Decimal], unit: StorageUnit = StorageUnit.AUTO)</code>","text":"<p>A class representing storage with different units.</p> <p>This class provides methods for converting between different storage units, performing arithmetic operations, and comparing storage sizes. It also includes methods for getting the size of files or directories and parsing storage values from strings.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>The numerical value of the storage as float (backward compatibility).</p> <code>decimal_value</code> <code>Decimal</code> <p>The exact decimal value with full precision.</p> <code>unit</code> <code>StorageUnit</code> <p>The unit of the storage value.</p> Class Attributes <p>_decimal_precision (int): Maximum number of decimal places to display (default: 20).</p> Decimal Precision <p>The Storage class uses Python's Decimal module internally to provide exact decimal precision, eliminating floating-point rounding errors. This ensures that values like \"6.682\" are stored and displayed exactly as \"6.682\" rather than \"6.68200000000000038369\".</p> <ul> <li>value property: Returns float for backward compatibility</li> <li>decimal_value property: Returns exact Decimal for precision-critical applications</li> <li>String representations use exact decimal formatting</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; storage = Storage(1, StorageUnit.KIB)\n&gt;&gt;&gt; print(storage.convert_to_bytes())\n1024.0\n</code></pre> <pre><code>&gt;&gt;&gt; total = Storage(512, StorageUnit.BYTES) + Storage(1, StorageUnit.KIB)\n&gt;&gt;&gt; print(total)\n1536.0 BYTES\n</code></pre> <pre><code>&gt;&gt;&gt; parsed = Storage.parse(\"1.5 MB\")\n&gt;&gt;&gt; print(parsed)\n1.5 MB\n</code></pre> <pre><code>&gt;&gt;&gt; # Exact decimal precision examples\n&gt;&gt;&gt; precise = Storage(\"6.682\", StorageUnit.MB)\n&gt;&gt;&gt; print(precise)  # Exact output: 6.682 MB\n6.682 MB\n&gt;&gt;&gt; precise.decimal_value  # Exact decimal\nDecimal('6.682')\n&gt;&gt;&gt; precise.value  # Float for compatibility\n6.682\n</code></pre> <pre><code>&gt;&gt;&gt; # Decimal arithmetic maintains precision\n&gt;&gt;&gt; a = Storage(\"1.1\", StorageUnit.GB)\n&gt;&gt;&gt; b = Storage(\"2.2\", StorageUnit.GB)\n&gt;&gt;&gt; result = a + b\n&gt;&gt;&gt; print(result)  # Exact: 3.3 GB\n3.3 GB\n&gt;&gt;&gt; result.decimal_value\nDecimal('3.3')\n</code></pre> <pre><code>&gt;&gt;&gt; # Configure decimal precision for display\n&gt;&gt;&gt; Storage.set_decimal_precision(10)\n&gt;&gt;&gt; small = Storage(\"0.000123456789012345\", StorageUnit.GB)\n&gt;&gt;&gt; print(small)  # Will show up to 10 decimal places\n0.0001234567890 GB\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[int, float, str, Decimal]</code> <p>The numerical value of the storage, or a string to parse (e.g., \"1MB\").   Can be int, float, str, or Decimal for exact precision.</p> required <code>unit</code> <code>StorageUnit</code> <p>The unit of the storage value. Defaults to StorageUnit.AUTO for automatic parsing.</p> <code>AUTO</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If value is not a number or string, or unit is not a StorageUnit.</p> <code>ValueError</code> <p>If value is negative or parsing fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; storage = Storage(1024, StorageUnit.BYTES)\n&gt;&gt;&gt; print(storage)\n1024 BYTES\n</code></pre> <pre><code>&gt;&gt;&gt; storage = Storage(\"1.5 MB\")  # Automatic parsing\n&gt;&gt;&gt; print(storage)\n1.5 MB\n</code></pre> <pre><code>&gt;&gt;&gt; storage = Storage(\"2048\")  # Defaults to bytes when no unit specified\n&gt;&gt;&gt; print(storage)\n2048 BYTES\n</code></pre> <pre><code>&gt;&gt;&gt; # Using Decimal for exact precision\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; storage = Storage(Decimal(\"6.682\"), StorageUnit.MB)\n&gt;&gt;&gt; print(storage)\n6.682 MB\n&gt;&gt;&gt; storage.decimal_value\nDecimal('6.682')\n</code></pre>"},{"location":"api/storage/#filesizelib.storage.Storage-attributes","title":"Attributes","text":""},{"location":"api/storage/#filesizelib.storage.Storage.value","title":"<code>value: float</code>  <code>property</code>","text":"<p>Get the storage value as a float for backward compatibility.</p> <p>This property maintains backward compatibility with existing code that expects float values. For applications requiring exact decimal precision, use the decimal_value property instead.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The storage value converted to float.</p> Note <p>Converting to float may introduce small precision errors for values that cannot be exactly represented in IEEE 754 floating-point format. Use decimal_value for exact precision.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; storage = Storage(\"6.682\", StorageUnit.MB)\n&gt;&gt;&gt; storage.value  # Returns float (may have tiny precision loss)\n6.682\n&gt;&gt;&gt; storage.decimal_value  # Returns exact Decimal\nDecimal('6.682')\n</code></pre>"},{"location":"api/storage/#filesizelib.storage.Storage.decimal_value","title":"<code>decimal_value: Decimal</code>  <code>property</code>","text":"<p>Get the exact decimal value with full precision.</p> <p>This property provides access to the internal Decimal representation that maintains exact precision for all decimal operations. Use this when you need guaranteed precision without any floating-point rounding errors.</p> <p>Returns:</p> Name Type Description <code>Decimal</code> <code>Decimal</code> <p>The exact decimal value without precision loss.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; storage = Storage(\"6.682\", StorageUnit.MB)\n&gt;&gt;&gt; storage.decimal_value\nDecimal('6.682')\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Decimal arithmetic maintains exact precision\n&gt;&gt;&gt; a = Storage(\"1.1\", StorageUnit.GB)\n&gt;&gt;&gt; b = Storage(\"2.2\", StorageUnit.GB)\n&gt;&gt;&gt; (a + b).decimal_value\nDecimal('3.3')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compare with float precision\n&gt;&gt;&gt; (a + b).value  # May show: 3.3000000000000003\n3.3\n</code></pre> Note <p>This is the recommended property for financial calculations, scientific applications, or any context where exact decimal precision is required.</p>"},{"location":"api/storage/#filesizelib.storage.Storage.BYTES","title":"<code>BYTES: Storage</code>  <code>property</code>","text":"<p>Property to convert to bytes.</p>"},{"location":"api/storage/#filesizelib.storage.Storage.KIB","title":"<code>KIB: Storage</code>  <code>property</code>","text":"<p>Property to convert to kibibytes (KiB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.MIB","title":"<code>MIB: Storage</code>  <code>property</code>","text":"<p>Property to convert to mebibytes (MiB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.GIB","title":"<code>GIB: Storage</code>  <code>property</code>","text":"<p>Property to convert to gibibytes (GiB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.TIB","title":"<code>TIB: Storage</code>  <code>property</code>","text":"<p>Property to convert to tebibytes (TiB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.PIB","title":"<code>PIB: Storage</code>  <code>property</code>","text":"<p>Property to convert to pebibytes (PiB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.EIB","title":"<code>EIB: Storage</code>  <code>property</code>","text":"<p>Property to convert to exbibytes (EiB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.ZIB","title":"<code>ZIB: Storage</code>  <code>property</code>","text":"<p>Property to convert to zebibytes (ZiB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.YIB","title":"<code>YIB: Storage</code>  <code>property</code>","text":"<p>Property to convert to yobibytes (YiB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.KB","title":"<code>KB: Storage</code>  <code>property</code>","text":"<p>Property to convert to kilobytes (KB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.MB","title":"<code>MB: Storage</code>  <code>property</code>","text":"<p>Property to convert to megabytes (MB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.GB","title":"<code>GB: Storage</code>  <code>property</code>","text":"<p>Property to convert to gigabytes (GB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.TB","title":"<code>TB: Storage</code>  <code>property</code>","text":"<p>Property to convert to terabytes (TB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.PB","title":"<code>PB: Storage</code>  <code>property</code>","text":"<p>Property to convert to petabytes (PB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.EB","title":"<code>EB: Storage</code>  <code>property</code>","text":"<p>Property to convert to exabytes (EB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.ZB","title":"<code>ZB: Storage</code>  <code>property</code>","text":"<p>Property to convert to zettabytes (ZB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.YB","title":"<code>YB: Storage</code>  <code>property</code>","text":"<p>Property to convert to yottabytes (YB).</p>"},{"location":"api/storage/#filesizelib.storage.Storage.BITS","title":"<code>BITS: Storage</code>  <code>property</code>","text":"<p>Property to convert to bits.</p>"},{"location":"api/storage/#filesizelib.storage.Storage.KILOBITS","title":"<code>KILOBITS: Storage</code>  <code>property</code>","text":"<p>Property to convert to kilobits.</p>"},{"location":"api/storage/#filesizelib.storage.Storage.MEGABITS","title":"<code>MEGABITS: Storage</code>  <code>property</code>","text":"<p>Property to convert to megabits.</p>"},{"location":"api/storage/#filesizelib.storage.Storage.GIGABITS","title":"<code>GIGABITS: Storage</code>  <code>property</code>","text":"<p>Property to convert to gigabits.</p>"},{"location":"api/storage/#filesizelib.storage.Storage.TERABITS","title":"<code>TERABITS: Storage</code>  <code>property</code>","text":"<p>Property to convert to terabits.</p>"},{"location":"api/storage/#filesizelib.storage.Storage-functions","title":"Functions","text":""},{"location":"api/storage/#filesizelib.storage.Storage.set_decimal_precision","title":"<code>set_decimal_precision(precision: int) -&gt; None</code>  <code>classmethod</code>","text":"<p>Set the maximum number of decimal places to display in string representations.</p> <p>This affects how numbers are formatted when converting Storage objects to strings, preventing scientific notation and allowing for precise decimal display.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>int</code> <p>Maximum number of decimal places to display. Must be &gt;= 0.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If precision is not an integer.</p> <code>ValueError</code> <p>If precision is negative.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Storage.set_decimal_precision(5)\n&gt;&gt;&gt; small = Storage(0.000123456789, StorageUnit.GB)  \n&gt;&gt;&gt; print(small)  # Will show: 0.00012 GB\n</code></pre> <pre><code>&gt;&gt;&gt; Storage.set_decimal_precision(15)\n&gt;&gt;&gt; print(small)  # Will show: 0.000123456789000 GB\n</code></pre>"},{"location":"api/storage/#filesizelib.storage.Storage.get_decimal_precision","title":"<code>get_decimal_precision() -&gt; int</code>  <code>classmethod</code>","text":"<p>Get the current maximum number of decimal places used in string representations.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Current decimal precision setting.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Storage.set_decimal_precision(10)\n&gt;&gt;&gt; print(Storage.get_decimal_precision())\n10\n</code></pre>"},{"location":"api/storage/#filesizelib.storage.Storage.parse_from_bytes","title":"<code>parse_from_bytes(value: Union[int, float, Decimal]) -&gt; Storage</code>  <code>classmethod</code>","text":"<p>Create a Storage instance from a value in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[int, float, Decimal]</code> <p>The value in bytes.</p> required <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>A Storage instance with the value in bytes.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If value is not a number.</p> <code>ValueError</code> <p>If value is negative.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; storage = Storage.parse_from_bytes(1024)\n&gt;&gt;&gt; print(storage)\n1024 BYTES\n</code></pre>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_bytes","title":"<code>convert_to_bytes() -&gt; Decimal</code>","text":"<p>Convert the storage value to bytes with exact decimal precision.</p> <p>This method returns a Decimal object to maintain exact precision during conversion operations. For backward compatibility with code expecting float values, you can convert the result using float().</p> <p>Returns:</p> Name Type Description <code>Decimal</code> <code>Decimal</code> <p>The value in bytes with exact precision.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; storage = Storage(1, StorageUnit.KIB)\n&gt;&gt;&gt; storage.convert_to_bytes()\nDecimal('1024')\n&gt;&gt;&gt; \n&gt;&gt;&gt; # For float compatibility\n&gt;&gt;&gt; float(storage.convert_to_bytes())\n1024.0\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Exact decimal precision maintained\n&gt;&gt;&gt; precise = Storage(\"1.5\", StorageUnit.KB)\n&gt;&gt;&gt; precise.convert_to_bytes()\nDecimal('1500')\n</code></pre>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to","title":"<code>convert_to(target_unit: StorageUnit) -&gt; Storage</code>","text":"<p>Convert the storage to a different unit.</p> <p>Parameters:</p> Name Type Description Default <code>target_unit</code> <code>StorageUnit</code> <p>The unit to convert to.</p> required <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>A new Storage instance with the converted value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; storage = Storage(1024, StorageUnit.BYTES)\n&gt;&gt;&gt; converted = storage.convert_to(StorageUnit.KIB)\n&gt;&gt;&gt; print(converted)\n1.0 KIB\n</code></pre>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_kib","title":"<code>convert_to_kib() -&gt; Storage</code>","text":"<p>Convert to kibibytes (KiB) - binary unit (1024 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in KiB.</p> Example <p>storage = Storage(2048, StorageUnit.BYTES) kib_storage = storage.convert_to_kib() print(kib_storage) 2.0 KIB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_mib","title":"<code>convert_to_mib() -&gt; Storage</code>","text":"<p>Convert to mebibytes (MiB) - binary unit (1024^2 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in MiB.</p> Example <p>storage = Storage(1, StorageUnit.GIB) mib_storage = storage.convert_to_mib() print(mib_storage) 1024.0 MIB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_gib","title":"<code>convert_to_gib() -&gt; Storage</code>","text":"<p>Convert to gibibytes (GiB) - binary unit (1024^3 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in GiB.</p> Example <p>storage = Storage(2048, StorageUnit.MIB) gib_storage = storage.convert_to_gib() print(gib_storage) 2.0 GIB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_tib","title":"<code>convert_to_tib() -&gt; Storage</code>","text":"<p>Convert to tebibytes (TiB) - binary unit (1024^4 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in TiB.</p> Example <p>storage = Storage(1024, StorageUnit.GIB) tib_storage = storage.convert_to_tib() print(tib_storage) 1.0 TIB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_pib","title":"<code>convert_to_pib() -&gt; Storage</code>","text":"<p>Convert to pebibytes (PiB) - binary unit (1024^5 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in PiB.</p> Example <p>storage = Storage(1024, StorageUnit.TIB) pib_storage = storage.convert_to_pib() print(pib_storage) 1.0 PIB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_eib","title":"<code>convert_to_eib() -&gt; Storage</code>","text":"<p>Convert to exbibytes (EiB) - binary unit (1024^6 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in EiB.</p> Example <p>storage = Storage(1024, StorageUnit.PIB) eib_storage = storage.convert_to_eib() print(eib_storage) 1.0 EIB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_zib","title":"<code>convert_to_zib() -&gt; Storage</code>","text":"<p>Convert to zebibytes (ZiB) - binary unit (1024^7 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in ZiB.</p> Example <p>storage = Storage(1024, StorageUnit.EIB) zib_storage = storage.convert_to_zib() print(zib_storage) 1.0 ZIB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_yib","title":"<code>convert_to_yib() -&gt; Storage</code>","text":"<p>Convert to yobibytes (YiB) - binary unit (1024^8 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in YiB.</p> Example <p>storage = Storage(1024, StorageUnit.ZIB) yib_storage = storage.convert_to_yib() print(yib_storage) 1.0 YIB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_kb","title":"<code>convert_to_kb() -&gt; Storage</code>","text":"<p>Convert to kilobytes (KB) - decimal unit (1000 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in KB.</p> Example <p>storage = Storage(2000, StorageUnit.BYTES) kb_storage = storage.convert_to_kb() print(kb_storage) 2.0 KB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_mb","title":"<code>convert_to_mb() -&gt; Storage</code>","text":"<p>Convert to megabytes (MB) - decimal unit (1000^2 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in MB.</p> Example <p>storage = Storage(1, StorageUnit.GB) mb_storage = storage.convert_to_mb() print(mb_storage) 1000.0 MB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_gb","title":"<code>convert_to_gb() -&gt; Storage</code>","text":"<p>Convert to gigabytes (GB) - decimal unit (1000^3 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in GB.</p> Example <p>storage = Storage(2000, StorageUnit.MB) gb_storage = storage.convert_to_gb() print(gb_storage) 2.0 GB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_tb","title":"<code>convert_to_tb() -&gt; Storage</code>","text":"<p>Convert to terabytes (TB) - decimal unit (1000^4 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in TB.</p> Example <p>storage = Storage(1000, StorageUnit.GB) tb_storage = storage.convert_to_tb() print(tb_storage) 1.0 TB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_pb","title":"<code>convert_to_pb() -&gt; Storage</code>","text":"<p>Convert to petabytes (PB) - decimal unit (1000^5 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in PB.</p> Example <p>storage = Storage(1000, StorageUnit.TB) pb_storage = storage.convert_to_pb() print(pb_storage) 1.0 PB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_eb","title":"<code>convert_to_eb() -&gt; Storage</code>","text":"<p>Convert to exabytes (EB) - decimal unit (1000^6 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in EB.</p> Example <p>storage = Storage(1000, StorageUnit.PB) eb_storage = storage.convert_to_eb() print(eb_storage) 1.0 EB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_zb","title":"<code>convert_to_zb() -&gt; Storage</code>","text":"<p>Convert to zettabytes (ZB) - decimal unit (1000^7 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in ZB.</p> Example <p>storage = Storage(1000, StorageUnit.EB) zb_storage = storage.convert_to_zb() print(zb_storage) 1.0 ZB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_yb","title":"<code>convert_to_yb() -&gt; Storage</code>","text":"<p>Convert to yottabytes (YB) - decimal unit (1000^8 bytes).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in YB.</p> Example <p>storage = Storage(1000, StorageUnit.ZB) yb_storage = storage.convert_to_yb() print(yb_storage) 1.0 YB</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_bits","title":"<code>convert_to_bits() -&gt; Storage</code>","text":"<p>Convert to bits - smallest unit (\u215b byte).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in bits.</p> Example <p>storage = Storage(1, StorageUnit.BYTES) bits_storage = storage.convert_to_bits() print(bits_storage) 8.0 BITS</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_kilobits","title":"<code>convert_to_kilobits() -&gt; Storage</code>","text":"<p>Convert to kilobits - decimal bit unit (1000 bits).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in kilobits.</p> Example <p>storage = Storage(1, StorageUnit.KB) kbits_storage = storage.convert_to_kilobits() print(kbits_storage) 8.0 KILOBITS</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_megabits","title":"<code>convert_to_megabits() -&gt; Storage</code>","text":"<p>Convert to megabits - decimal bit unit (1000^2 bits).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in megabits.</p> Example <p>storage = Storage(1, StorageUnit.MB) mbits_storage = storage.convert_to_megabits() print(mbits_storage) 8.0 MEGABITS</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_gigabits","title":"<code>convert_to_gigabits() -&gt; Storage</code>","text":"<p>Convert to gigabits - decimal bit unit (1000^3 bits).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in gigabits.</p> Example <p>storage = Storage(1, StorageUnit.GB) gbits_storage = storage.convert_to_gigabits() print(gbits_storage) 8.0 GIGABITS</p>"},{"location":"api/storage/#filesizelib.storage.Storage.convert_to_terabits","title":"<code>convert_to_terabits() -&gt; Storage</code>","text":"<p>Convert to terabits - decimal bit unit (1000^4 bits).</p> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>New Storage object with value in terabits.</p> Example <p>storage = Storage(1, StorageUnit.TB) tbits_storage = storage.convert_to_terabits() print(tbits_storage) 8.0 TERABITS</p>"},{"location":"api/storage/#filesizelib.storage.Storage.parse","title":"<code>parse(string: str, default_unit: Optional[StorageUnit] = None) -&gt; Storage</code>  <code>classmethod</code>","text":"<p>Parse a string to create a Storage instance.</p> <p>The string should be in the format \"value unit\", where value is a number and unit is one of the supported storage units. The parsing is: - Case insensitive - Supports both '.' and ',' as decimal separators - Supports spaces and no spaces between value and unit - Uses bytes as default unit if unit is not recognized or provided</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>A string representing the storage value.</p> required <code>default_unit</code> <code>Optional[StorageUnit]</code> <p>The unit to use if no unit is found or recognized.          Defaults to StorageUnit.BYTES.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>A Storage instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input string is invalid or cannot be parsed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; storage = Storage.parse(\"1.5 MB\")\n&gt;&gt;&gt; print(storage)\n1.5 MB\n</code></pre> <pre><code>&gt;&gt;&gt; storage = Storage.parse(\"1,024 KiB\")\n&gt;&gt;&gt; print(storage) \n1024.0 KIB\n</code></pre> <pre><code>&gt;&gt;&gt; storage = Storage.parse(\"500\")  # defaults to bytes\n&gt;&gt;&gt; print(storage)\n500.0 BYTES\n</code></pre>"},{"location":"api/storage/#filesizelib.storage.Storage.get_size_from_path","title":"<code>get_size_from_path(path: Union[str, Path]) -&gt; Storage</code>  <code>staticmethod</code>","text":"<p>Get the size of a file or directory from the given path.</p> <p>This method calculates the total size of a file or directory (including all subdirectories and files) using pathlib.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the file or directory (string or Path object).</p> required <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>A Storage instance representing the total size in bytes.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the path does not exist.</p> <code>PermissionError</code> <p>If access to the path is denied.</p> <code>OSError</code> <p>If an OS-level error occurs while accessing the path.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; size = Storage.get_size_from_path(\"/path/to/file.txt\")\n&gt;&gt;&gt; print(size)\n1024.0 BYTES\n</code></pre> <pre><code>&gt;&gt;&gt; dir_size = Storage.get_size_from_path(\"/path/to/directory\")\n&gt;&gt;&gt; print(dir_size.auto_scale())\n15.2 MIB\n</code></pre>"},{"location":"api/storage/#filesizelib.storage.Storage.get_platform_storage","title":"<code>get_platform_storage() -&gt; Storage</code>  <code>staticmethod</code>","text":"<p>Get the appropriate platform-specific storage instance.</p> <p>This method automatically detects the current platform and returns the corresponding storage handler that may include platform-specific optimizations for file size retrieval.</p> <p>Returns:</p> Type Description <code>Storage</code> <p>Storage subclass: A platform-specific storage instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the platform is not supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; platform_storage = Storage.get_platform_storage()\n&gt;&gt;&gt; size = platform_storage.get_size_from_path(\"/some/path\")\n</code></pre>"},{"location":"api/storage/#filesizelib.storage.Storage.auto_scale","title":"<code>auto_scale(prefer_binary: bool = True) -&gt; Storage</code>","text":"<p>Automatically scale the storage to the most appropriate unit.</p> <p>This method converts the storage to a unit that results in a value between 1 and 1024 (for binary) or 1000 (for decimal), making it more human-readable.</p> <p>Parameters:</p> Name Type Description Default <code>prefer_binary</code> <code>bool</code> <p>If True, prefer binary units (KiB, MiB, etc.).           If False, prefer decimal units (KB, MB, etc.).</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Storage</code> <code>Storage</code> <p>A new Storage instance with an appropriate unit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; storage = Storage(1536, StorageUnit.BYTES)\n&gt;&gt;&gt; scaled = storage.auto_scale()\n&gt;&gt;&gt; print(scaled)\n1.5 KIB\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Real-world examples and practical use cases for Bytesize.</p>"},{"location":"examples/#overview","title":"\ud83c\udfaf Overview","text":"<p>This section provides practical examples showing how to use Bytesize in real applications. Each example includes complete, runnable code with explanations.</p>"},{"location":"examples/#example-categories","title":"\ud83d\udcda Example Categories","text":"<ul> <li> <p> Basic Usage</p> <p>Simple examples to get you started quickly</p> </li> <li> <p> Real-World Scenarios</p> <p>Production-ready examples from actual use cases</p> </li> <li> <p> Best Practices</p> <p>Optimization techniques and best practices</p> </li> </ul>"},{"location":"examples/#quick-examples","title":"\ud83d\ude80 Quick Examples","text":""},{"location":"examples/#file-size-analysis","title":"File Size Analysis","text":"<pre><code>from bytesize import Storage, StorageUnit\nfrom pathlib import Path\n\ndef analyze_directory(path: str):\n    \"\"\"Analyze directory size and file distribution.\"\"\"\n    directory = Path(path)\n    total_size = Storage(0, StorageUnit.BYTES)\n    file_count = 0\n\n    for file_path in directory.rglob('*'):\n        if file_path.is_file():\n            file_size = Storage.get_size_from_path(file_path)\n            total_size += file_size\n            file_count += 1\n            print(f\"{file_path.name}: {file_size.auto_scale()}\")\n\n    print(f\"\\nTotal: {file_count} files, {total_size.auto_scale()}\")\n    return total_size\n\n# Usage\ntotal = analyze_directory(\"./docs\")\n</code></pre>"},{"location":"examples/#bandwidth-calculator","title":"Bandwidth Calculator","text":"<pre><code>def calculate_download_time(file_size: str, speed: str) -&gt; float:\n    \"\"\"Calculate download time given file size and connection speed.\"\"\"\n    file_storage = Storage.parse(file_size)\n    speed_storage = Storage.parse(speed)\n\n    # Convert to compatible units (bits)\n    file_bits = file_storage.convert_to_bits()\n    speed_bits_per_sec = speed_storage.convert_to_bits()\n\n    # Calculate time in seconds\n    time_seconds = file_bits.value / speed_bits_per_sec.value\n\n    return time_seconds\n\n# Usage examples\ntime1 = calculate_download_time(\"1.5 GB\", \"100 Megabits\")\ntime2 = calculate_download_time(\"4K movie.mkv\", \"1 Gigabit\")\n\nprint(f\"Download time: {time1:.1f} seconds\")\nprint(f\"4K movie time: {time2:.1f} seconds\")\n</code></pre>"},{"location":"examples/#storage-planning","title":"Storage Planning","text":"<pre><code>class StoragePlanner:\n    \"\"\"Plan storage requirements for different media types.\"\"\"\n\n    def __init__(self, total_capacity: str):\n        self.capacity = Storage.parse(total_capacity)\n        self.used = Storage(0, StorageUnit.BYTES)\n        self.allocations = {}\n\n    def add_allocation(self, name: str, size: str, count: int = 1):\n        \"\"\"Add a storage allocation.\"\"\"\n        unit_size = Storage.parse(size)\n        total_size = unit_size * count\n\n        self.allocations[name] = {\n            'unit_size': unit_size,\n            'count': count,\n            'total_size': total_size\n        }\n        self.used += total_size\n\n    def get_report(self) -&gt; str:\n        \"\"\"Generate a storage planning report.\"\"\"\n        report = f\"Storage Capacity: {self.capacity}\\n\"\n        report += f\"Total Used: {self.used.auto_scale()}\\n\"\n        report += f\"Remaining: {(self.capacity - self.used).auto_scale()}\\n\\n\"\n\n        report += \"Allocations:\\n\"\n        for name, alloc in self.allocations.items():\n            report += f\"  {name}: {alloc['count']} \u00d7 {alloc['unit_size'].auto_scale()} = {alloc['total_size'].auto_scale()}\\n\"\n\n        usage_percent = (self.used / self.capacity) * 100\n        report += f\"\\nUsage: {usage_percent:.1f}%\"\n\n        return report\n\n# Usage\nplanner = StoragePlanner(\"1 TB\")\nplanner.add_allocation(\"Photos\", \"2.5 MiB\", 2000)\nplanner.add_allocation(\"Music\", \"4.5 MB\", 500)\nplanner.add_allocation(\"Videos\", \"800 MB\", 20)\nplanner.add_allocation(\"Documents\", \"150 KB\", 1000)\n\nprint(planner.get_report())\n</code></pre>"},{"location":"examples/#conversion-examples","title":"\ud83d\udd04 Conversion Examples","text":""},{"location":"examples/#unit-converter","title":"Unit Converter","text":"<pre><code>class UnitConverter:\n    \"\"\"Interactive unit converter.\"\"\"\n\n    @staticmethod\n    def convert_all_units(value: str) -&gt; dict:\n        \"\"\"Convert to all unit types.\"\"\"\n        storage = Storage.parse(value)\n\n        return {\n            'binary': {\n                'bytes': storage.convert_to_bytes(),\n                'kib': storage.convert_to_kib(),\n                'mib': storage.convert_to_mib(),\n                'gib': storage.convert_to_gib(),\n                'tib': storage.convert_to_tib(),\n            },\n            'decimal': {\n                'kb': storage.convert_to_kb(),\n                'mb': storage.convert_to_mb(),\n                'gb': storage.convert_to_gb(),\n                'tb': storage.convert_to_tb(),\n            },\n            'bits': {\n                'bits': storage.convert_to_bits(),\n                'kilobits': storage.convert_to_kilobits(),\n                'megabits': storage.convert_to_megabits(),\n                'gigabits': storage.convert_to_gigabits(),\n            }\n        }\n\n    @staticmethod\n    def print_conversions(value: str):\n        \"\"\"Print all conversions in a formatted way.\"\"\"\n        conversions = UnitConverter.convert_all_units(value)\n\n        print(f\"Converting: {value}\")\n        print(\"=\" * 40)\n\n        for category, units in conversions.items():\n            print(f\"\\n{category.title()} Units:\")\n            for unit_name, storage in units.items():\n                print(f\"  {unit_name}: {storage}\")\n\n# Usage\nUnitConverter.print_conversions(\"1.5 GB\")\n</code></pre>"},{"location":"examples/#comparison-examples","title":"\ud83d\udcca Comparison Examples","text":""},{"location":"examples/#size-comparison-tool","title":"Size Comparison Tool","text":"<pre><code>def compare_sizes(*size_strings):\n    \"\"\"Compare multiple sizes and show relationships.\"\"\"\n    sizes = [Storage.parse(size) for size in size_strings]\n\n    # Sort by size\n    sorted_sizes = sorted(zip(size_strings, sizes), key=lambda x: x[1].convert_to_bytes())\n\n    print(\"Size Comparison (smallest to largest):\")\n    print(\"=\" * 50)\n\n    largest = sorted_sizes[-1][1]\n\n    for i, (original, storage) in enumerate(sorted_sizes):\n        ratio = largest / storage\n        percentage = (storage / largest) * 100\n\n        print(f\"{i+1}. {original}\")\n        print(f\"   = {storage.auto_scale()}\")\n        print(f\"   = {percentage:.1f}% of largest\")\n        print(f\"   = {ratio:.2f}x smaller than largest\")\n        print()\n\n# Usage\ncompare_sizes(\"1.5 GB\", \"1600 MB\", \"1.6 GB\", \"1500000 KB\")\n</code></pre>"},{"location":"examples/#interactive-examples","title":"\ud83c\udfae Interactive Examples","text":""},{"location":"examples/#file-size-calculator","title":"File Size Calculator","text":"<pre><code>class FileSizeCalculator:\n    \"\"\"Calculate various file size scenarios.\"\"\"\n\n    @staticmethod\n    def backup_time(data_size: str, backup_speed: str) -&gt; str:\n        \"\"\"Calculate backup time.\"\"\"\n        data = Storage.parse(data_size)\n        speed = Storage.parse(backup_speed)\n\n        time_seconds = data / speed\n        hours = time_seconds / 3600\n\n        if hours &lt; 1:\n            minutes = time_seconds / 60\n            return f\"{minutes:.1f} minutes\"\n        elif hours &lt; 24:\n            return f\"{hours:.1f} hours\"\n        else:\n            days = hours / 24\n            return f\"{days:.1f} days\"\n\n    @staticmethod\n    def storage_lifespan(capacity: str, daily_usage: str) -&gt; str:\n        \"\"\"Calculate how long storage will last.\"\"\"\n        total = Storage.parse(capacity)\n        daily = Storage.parse(daily_usage)\n\n        days = total / daily\n\n        if days &lt; 30:\n            return f\"{days:.1f} days\"\n        elif days &lt; 365:\n            months = days / 30\n            return f\"{months:.1f} months\"\n        else:\n            years = days / 365\n            return f\"{years:.1f} years\"\n\n    @staticmethod\n    def compression_analysis(original: str, compressed: str) -&gt; dict:\n        \"\"\"Analyze compression efficiency.\"\"\"\n        orig_size = Storage.parse(original)\n        comp_size = Storage.parse(compressed)\n\n        saved = orig_size - comp_size\n        ratio = orig_size / comp_size\n        percentage = (saved / orig_size) * 100\n\n        return {\n            'original': orig_size,\n            'compressed': comp_size,\n            'saved': saved,\n            'ratio': f\"{ratio:.2f}:1\",\n            'percentage': f\"{percentage:.1f}%\"\n        }\n\n# Usage examples\nprint(\"Backup time:\", FileSizeCalculator.backup_time(\"500 GB\", \"100 MB\"))\nprint(\"Storage lifespan:\", FileSizeCalculator.storage_lifespan(\"1 TB\", \"2 GB\"))\n\ncompression = FileSizeCalculator.compression_analysis(\"100 MB\", \"23 MB\")\nprint(\"Compression analysis:\", compression)\n</code></pre>"},{"location":"examples/#next-steps","title":"\ud83d\udd0d Next Steps","text":"<p>Ready to explore more detailed examples?</p> <ul> <li> <p> Basic Usage</p> <p>Start with simple, fundamental examples</p> </li> <li> <p> Real-World Use Cases</p> <p>See production-ready applications</p> </li> <li> <p> Best Practices</p> <p>Learn optimization techniques and patterns</p> </li> </ul> <p>All examples are tested and ready to run. Copy and paste them into your Python environment to try them out!</p>"},{"location":"examples/basic/","title":"Basic Usage Examples","text":"<p>Simple, fundamental examples to get you started with FileSizeLib quickly.</p>"},{"location":"examples/basic/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"examples/basic/#creating-storage-objects","title":"Creating Storage Objects","text":"<p>The most basic way to work with storage values:</p> <pre><code>from filesizelib import Storage, StorageUnit, FileSizeLib\n\n# Method 1: Constructor with value and unit (Storage and FileSizeLib are identical)\nfile_size = Storage(1.5, StorageUnit.GB)\nmemory = FileSizeLib(8, StorageUnit.GIB)  # Using alias\nsmall_file = Storage(512, StorageUnit.BYTES)\n\nprint(f\"File: {file_size}\")      # File: 1.5 GB\nprint(f\"Memory: {memory}\")       # Memory: 8.0 GIB\nprint(f\"Small: {small_file}\")    # Small: 512 BYTES (integers don't show .0)\n</code></pre>"},{"location":"examples/basic/#parsing-from-strings","title":"Parsing from Strings","text":"<p>Convert human-readable strings into Storage objects:</p> <pre><code># Method 2: Parse from strings (recommended for user input)\ndownload = Storage.parse(\"150 MB\")\nbackup = FileSizeLib.parse(\"2.3 TB\")  # Using alias\ncache = Storage.parse(\"512 MiB\")\n\nprint(f\"Download: {download}\")   # Download: 150 MB\nprint(f\"Backup: {backup}\")       # Backup: 2.3 TB\nprint(f\"Cache: {cache}\")         # Cache: 512 MIB\n\n# Flexible parsing formats\nflexible_examples = [\n    Storage.parse(\"1.5GB\"),        # No space\n    FileSizeLib.parse(\"1,5 GB\"),      # European decimal separator (using alias)\n    Storage.parse(\"1024 kb\"),      # Lowercase units\n    FileSizeLib.parse(\"2 terabytes\"), # Full unit names (using alias)\n]\n\nfor storage in flexible_examples:\n    print(storage)\n</code></pre>"},{"location":"examples/basic/#working-with-files","title":"Working with Files","text":"<p>Get file and directory sizes:</p> <pre><code>from pathlib import Path\n\n# Method 3: From file system\nreadme_size = Storage.get_size_from_path(\"README.md\")\ndocs_size = FileSizeLib.get_size_from_path(\"./docs\")  # Using alias\n\nprint(f\"README size: {readme_size.auto_scale()}\")\nprint(f\"Documentation size: {docs_size.auto_scale()}\")\n\n# Works with Path objects too\nconfig_path = Path(\"config.json\")\nconfig_size = Storage.get_size_from_path(config_path)\nprint(f\"Config size: {config_size}\")\n</code></pre>"},{"location":"examples/basic/#smart-arithmetic","title":"\ud83e\uddee Smart Arithmetic","text":""},{"location":"examples/basic/#same-unit-vs-mixed-unit-operations","title":"Same-Unit vs Mixed-Unit Operations","text":"<p>FileSizeLib now features intelligent arithmetic that preserves units when both operands have the same unit:</p> <pre><code># Same-unit operations preserve the unit\nsame_unit_1 = Storage(1, StorageUnit.GB)\nsame_unit_2 = Storage(2, StorageUnit.GB)\ntotal_same = same_unit_1 + same_unit_2\nprint(f\"Same units: {total_same}\")  # 3 GB (unit preserved!)\n\n# Mixed-unit operations convert to bytes\nmixed_1 = Storage(1, StorageUnit.GB)\nmixed_2 = Storage(500, StorageUnit.MB)\ntotal_mixed = mixed_1 + mixed_2\nprint(f\"Mixed units: {total_mixed}\")  # 1500000000 BYTES\n\n# Use auto_scale for readability\nprint(f\"Readable: {total_mixed.auto_scale()}\")  # 1.4 GIB\n</code></pre>"},{"location":"examples/basic/#addition-and-subtraction","title":"Addition and Subtraction","text":"<pre><code># File size calculations\nvideo_file = Storage(4.7, StorageUnit.GB)    # DVD movie\nsubtitle_file = Storage(50, StorageUnit.KB)  # Subtitle file\n\n# Mixed units convert to bytes\ntotal_download = video_file + subtitle_file\nprint(f\"Total download: {total_download.auto_scale()}\")  # 4.37 GIB\n\n# Same-unit subtraction preserves unit\ndisk_capacity = Storage(500, StorageUnit.GB)\nused_space = Storage(387, StorageUnit.GB)\nfree_space = disk_capacity - used_space\nprint(f\"Free space: {free_space}\")  # 113 GB (unit preserved!)\n</code></pre>"},{"location":"examples/basic/#multiplication-and-division","title":"Multiplication and Division","text":"<pre><code># Calculate space needed for multiple files\nsingle_photo = Storage(2.5, StorageUnit.MB)\nphoto_count = 100\n\ntotal_photos = single_photo * photo_count\nprint(f\"100 photos: {total_photos.auto_scale()}\")  # 250.0 MB\n\n# Calculate ratios\nlarge_file = Storage(1, StorageUnit.GB)\nsmall_file = Storage(50, StorageUnit.MB)\n\nratio = large_file / small_file\nprint(f\"Large file is {ratio}x bigger\")  # 20.0x bigger\n\n# Split storage\nper_user = total_photos / 4\nprint(f\"Per user: {per_user}\")  # 62.5 MB\n</code></pre>"},{"location":"examples/basic/#unit-conversions","title":"\ud83d\udd04 Unit Conversions","text":""},{"location":"examples/basic/#traditional-conversion-method","title":"Traditional Conversion Method","text":"<pre><code># Using convert_to() with target unit\nstorage = Storage(1024, StorageUnit.BYTES)\n\n# Convert to different units\nkib_size = storage.convert_to(StorageUnit.KIB)\nkb_size = storage.convert_to(StorageUnit.KB)\n\nprint(f\"In KiB: {kib_size}\")  # 1.0 KIB (binary)\nprint(f\"In KB: {kb_size}\")   # 1.024 KB (decimal)\n</code></pre>"},{"location":"examples/basic/#convenient-conversion-methods","title":"Convenient Conversion Methods","text":"<pre><code># Using convenient conversion methods (recommended)\nlarge_file = Storage(1.5, StorageUnit.GB)\n\n# Binary conversions\nprint(f\"GiB: {large_file.convert_to_gib()}\")  # 1.396 GiB\nprint(f\"MiB: {large_file.convert_to_mib()}\")  # 1430.5 MiB\n\n# Decimal conversions  \nprint(f\"MB: {large_file.convert_to_mb()}\")    # 1500.0 MB\nprint(f\"KB: {large_file.convert_to_kb()}\")    # 1500000.0 KB\n\n# Bit conversions\nprint(f\"Bits: {large_file.convert_to_bits()}\")      # 12000000000.0 BITS\nprint(f\"Megabits: {large_file.convert_to_megabits()}\") # 12000.0 MEGABITS\n</code></pre>"},{"location":"examples/basic/#auto-scaling-for-readability","title":"Auto-Scaling for Readability","text":"<pre><code># Auto-scale to most appropriate unit\nhuge_number = Storage(1536000000, StorageUnit.BYTES)\n\nprint(f\"Raw: {huge_number}\")                              # 1536000000.0 BYTES\nprint(f\"Auto-scaled: {huge_number.auto_scale()}\")         # 1.43 GIB\nprint(f\"Prefer decimal: {huge_number.auto_scale(prefer_binary=False)}\")  # 1.536 GB\n</code></pre>"},{"location":"examples/basic/#comparisons","title":"\ud83d\udd0d Comparisons","text":""},{"location":"examples/basic/#basic-comparisons","title":"Basic Comparisons","text":"<pre><code>file1 = Storage(1, StorageUnit.GB)\nfile2 = Storage(1000, StorageUnit.MB)\nfile3 = Storage(1.5, StorageUnit.GB)\n\n# Equality (handles unit differences automatically)\nprint(f\"1 GB == 1000 MB: {file1 == file2}\")  # True\nprint(f\"1 GB != 1.5 GB: {file1 != file3}\")   # True\n\n# Size comparisons\nprint(f\"1.5 GB &gt; 1 GB: {file3 &gt; file1}\")     # True\nprint(f\"1 GB &lt; 1.5 GB: {file1 &lt; file3}\")     # True\nprint(f\"1 GB &gt;= 1000 MB: {file1 &gt;= file2}\")  # True\n</code></pre>"},{"location":"examples/basic/#finding-largestsmallest","title":"Finding Largest/Smallest","text":"<pre><code>file_sizes = [\n    Storage(150, StorageUnit.MB),\n    Storage(1.2, StorageUnit.GB),\n    Storage(800, StorageUnit.MB),\n    Storage(2.1, StorageUnit.GIB)\n]\n\n# Find largest and smallest\nlargest = max(file_sizes)\nsmallest = min(file_sizes)\n\nprint(f\"Largest: {largest.auto_scale()}\")   # 2.1 GIB\nprint(f\"Smallest: {smallest.auto_scale()}\") # 150.0 MB\n</code></pre>"},{"location":"examples/basic/#practical-examples","title":"\ud83d\udcca Practical Examples","text":""},{"location":"examples/basic/#download-time-calculator","title":"Download Time Calculator","text":"<pre><code>def calculate_download_time(file_size_str: str, speed_str: str) -&gt; str:\n    \"\"\"Calculate download time for a file.\"\"\"\n    file_size = Storage.parse(file_size_str)\n    speed = FileSizeLib.parse(speed_str)  # Using alias\n\n    # Convert to bits for bandwidth calculation\n    file_bits = file_size.convert_to_bits()\n    speed_bits = speed.convert_to_bits()\n\n    # Calculate time in seconds\n    seconds = file_bits.value / speed_bits.value\n\n    # Format output\n    if seconds &lt; 60:\n        return f\"{seconds:.1f} seconds\"\n    elif seconds &lt; 3600:\n        return f\"{seconds/60:.1f} minutes\"\n    else:\n        return f\"{seconds/3600:.1f} hours\"\n\n# Examples\nprint(calculate_download_time(\"100 MB\", \"10 Megabits\"))   # 80.0 seconds\nprint(calculate_download_time(\"4.7 GB\", \"50 Megabits\"))   # 12.5 minutes\nprint(calculate_download_time(\"25 GB\", \"1 Gigabit\"))      # 3.3 minutes\n</code></pre>"},{"location":"examples/basic/#disk-space-monitor","title":"Disk Space Monitor","text":"<pre><code>def check_disk_space(path: str, warning_threshold: str = \"1 GB\"):\n    \"\"\"Check if disk space is getting low.\"\"\"\n    try:\n        # Get directory size (this is a simple example)\n        used_space = FileSizeLib.get_size_from_path(path)  # Using alias\n        threshold = Storage.parse(warning_threshold)\n\n        print(f\"Directory: {path}\")\n        print(f\"Used space: {used_space.auto_scale()}\")\n\n        if used_space &gt; threshold:\n            print(f\"\u26a0\ufe0f  Warning: Directory is larger than {threshold}\")\n        else:\n            print(f\"\u2705 OK: Directory is under {threshold}\")\n\n    except FileNotFoundError:\n        print(f\"\u274c Error: Path '{path}' not found\")\n\n# Usage\ncheck_disk_space(\"./docs\", \"10 MB\")\ncheck_disk_space(\"./tests\", \"5 MB\")\n</code></pre>"},{"location":"examples/basic/#file-size-categorizer","title":"File Size Categorizer","text":"<pre><code>def categorize_file_size(file_path: str) -&gt; str:\n    \"\"\"Categorize a file by its size.\"\"\"\n    try:\n        size = FileSizeLib.get_size_from_path(file_path)  # Using alias\n        size_bytes = size.convert_to_bytes()\n\n        if size_bytes &lt; 1024:  # &lt; 1 KB\n            return \"tiny\"\n        elif size_bytes &lt; 1024**2:  # &lt; 1 MB\n            return \"small\"\n        elif size_bytes &lt; 1024**3:  # &lt; 1 GB\n            return \"medium\"\n        else:  # &gt;= 1 GB\n            return \"large\"\n\n    except FileNotFoundError:\n        return \"not_found\"\n\n# Example usage\nfiles = [\"README.md\", \"setup.py\", \"docs/index.md\"]\nfor file_path in files:\n    category = categorize_file_size(file_path)\n    size = Storage.get_size_from_path(file_path) if category != \"not_found\" else \"N/A\"\n    print(f\"{file_path}: {category} ({size})\")\n</code></pre>"},{"location":"examples/basic/#data-usage-tracker","title":"Data Usage Tracker","text":"<pre><code>class DataUsageTracker:\n    \"\"\"Track data usage over time.\"\"\"\n\n    def __init__(self, monthly_limit: str):\n        self.monthly_limit = FileSizeLib.parse(monthly_limit)  # Using alias\n        self.current_usage = Storage(0, StorageUnit.BYTES)\n        self.daily_usage = []\n\n    def add_usage(self, amount: str):\n        \"\"\"Add data usage.\"\"\"\n        usage = FileSizeLib.parse(amount)  # Using alias\n        self.current_usage += usage\n        self.daily_usage.append(usage)\n        print(f\"Added {usage}, total: {self.current_usage.auto_scale()}\")\n\n    def get_remaining(self) -&gt; Storage:\n        \"\"\"Get remaining data allowance.\"\"\"\n        return self.monthly_limit - self.current_usage\n\n    def get_usage_percentage(self) -&gt; float:\n        \"\"\"Get usage as percentage of limit.\"\"\"\n        return (self.current_usage / self.monthly_limit) * 100\n\n    def status_report(self):\n        \"\"\"Print usage status.\"\"\"\n        remaining = self.get_remaining()\n        percentage = self.get_usage_percentage()\n\n        print(f\"\\n\ud83d\udcca Data Usage Report\")\n        print(f\"Limit: {self.monthly_limit}\")\n        print(f\"Used: {self.current_usage.auto_scale()} ({percentage:.1f}%)\")\n        print(f\"Remaining: {remaining.auto_scale()}\")\n\n        if percentage &gt; 90:\n            print(\"\ud83d\udea8 Warning: Approaching data limit!\")\n        elif percentage &gt; 75:\n            print(\"\u26a0\ufe0f  Caution: 75% of data used\")\n        else:\n            print(\"\u2705 Usage within normal range\")\n\n# Usage example\ntracker = DataUsageTracker(\"50 GB\")\ntracker.add_usage(\"1.2 GB\")  # Video streaming\ntracker.add_usage(\"500 MB\")  # Web browsing\ntracker.add_usage(\"2.1 GB\")  # Software download\ntracker.status_report()\n</code></pre>"},{"location":"examples/basic/#string-formatting-decimal-precision","title":"\ud83c\udfaf String Formatting &amp; Decimal Precision","text":""},{"location":"examples/basic/#configurable-precision-no-scientific-notation","title":"Configurable Precision (No Scientific Notation)","text":"<pre><code># FileSizeLib eliminates scientific notation by default\nsmall_value = Storage(9.872019291e-05, StorageUnit.GIB)\nprint(f\"No scientific notation: {small_value}\")  # 0.00009872019291 GIB\n\n# Configure global precision\nStorage.set_decimal_precision(5)\nprint(f\"5 decimals: {small_value}\")  # 0.0001 GIB\n\n# Check current precision\nprint(f\"Current: {FileSizeLib.get_decimal_precision()}\")  # 5\n\n# Reset to default\nStorage.set_decimal_precision(20)\n</code></pre>"},{"location":"examples/basic/#display-formatting","title":"Display Formatting","text":"<pre><code>storage = Storage(1234.5678, StorageUnit.MB)\n\n# Default string representation (uses configured precision)\nprint(f\"Default: {storage}\")           # 1234.5678 MB\n\n# Custom precision using format\nprint(f\"2 decimals: {storage:.2f}\")    # 1234.57 MB\nprint(f\"No decimals: {storage:.0f}\")   # 1235 MB\nprint(f\"4 decimals: {storage:.4f}\")    # 1234.5678 MB\n\n# Auto-scaled formatting\nprint(f\"Auto-scaled: {storage.auto_scale()}\")  # 1.17 GIB\n</code></pre>"},{"location":"examples/basic/#repr-for-debugging","title":"Repr for Debugging","text":"<pre><code>storage = Storage(1.5, StorageUnit.GB)\n\n# String representation (for users)\nprint(str(storage))   # 1.5 GB\n\n# Repr representation (for developers)\nprint(repr(storage))  # Storage(1.5, StorageUnit.GB)\n\n# Both in one\nprint(f\"Value: {storage!s}, Debug: {storage!r}\")\n</code></pre>"},{"location":"examples/basic/#error-handling-basics","title":"\u2705 Error Handling Basics","text":""},{"location":"examples/basic/#common-error-scenarios","title":"Common Error Scenarios","text":"<pre><code># Handle parsing errors\ndef safe_parse(size_string: str) -&gt; Storage:\n    \"\"\"Safely parse size string.\"\"\"\n    try:\n        return FileSizeLib.parse(size_string)  # Using alias\n    except ValueError as e:\n        print(f\"Parse error: {e}\")\n        return Storage(0, StorageUnit.BYTES)  # Default fallback\n\n# Examples\nprint(safe_parse(\"1.5 GB\"))    # 1.5 GB\nprint(safe_parse(\"invalid\"))   # 0.0 BYTES (with error message)\n\n# Handle file operation errors\ndef safe_file_size(file_path: str) -&gt; Storage:\n    \"\"\"Safely get file size.\"\"\"\n    try:\n        return FileSizeLib.get_size_from_path(file_path)  # Using alias\n    except FileNotFoundError:\n        print(f\"File not found: {file_path}\")\n        return Storage(0, StorageUnit.BYTES)\n    except PermissionError:\n        print(f\"Permission denied: {file_path}\")\n        return Storage(0, StorageUnit.BYTES)\n\n# Handle arithmetic errors\ndef safe_divide(dividend: Storage, divisor: Storage) -&gt; float:\n    \"\"\"Safely divide two storage values.\"\"\"\n    try:\n        return dividend / divisor\n    except ZeroDivisionError:\n        print(\"Cannot divide by zero\")\n        return 0.0\n</code></pre>"},{"location":"examples/basic/#next-steps","title":"\ud83d\udd17 Next Steps","text":"<p>Ready to explore more advanced features?</p> <ul> <li> <p> Real-World Use Cases</p> <p>Production-ready examples and patterns</p> </li> <li> <p> Best Practices</p> <p>Optimization techniques and best practices</p> </li> <li> <p> API Reference</p> <p>Complete documentation of all methods</p> </li> </ul> <p>These basic examples provide a solid foundation for using FileSizeLib. All examples are tested and ready to run!</p>"},{"location":"examples/real-world/","title":"Real-World Use Cases","text":"<p>Production-ready examples demonstrating Bytesize in real applications and scenarios.</p>"},{"location":"examples/real-world/#web-development","title":"\ud83c\udf10 Web Development","text":""},{"location":"examples/real-world/#file-upload-handler","title":"File Upload Handler","text":"<p>A robust file upload system with size validation and progress tracking:</p> <pre><code>import os\nimport shutil\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\nfrom bytesize import Storage, StorageUnit\n\nclass FileUploadHandler:\n    \"\"\"Production-ready file upload handler with size management.\"\"\"\n\n    def __init__(self, upload_dir: str, max_file_size: str = \"100 MB\", \n                 max_total_size: str = \"1 GB\"):\n        self.upload_dir = Path(upload_dir)\n        self.upload_dir.mkdir(exist_ok=True)\n        self.max_file_size = Storage.parse(max_file_size)\n        self.max_total_size = Storage.parse(max_total_size)\n\n    def validate_upload(self, file_path: str, filename: str) -&gt; Dict[str, any]:\n        \"\"\"Validate file upload against size constraints.\"\"\"\n        try:\n            file_size = Storage.get_size_from_path(file_path)\n            current_total = self._calculate_current_usage()\n\n            # Check individual file size\n            if file_size &gt; self.max_file_size:\n                return {\n                    'valid': False,\n                    'error': 'FILE_TOO_LARGE',\n                    'message': f'File size {file_size.auto_scale()} exceeds limit of {self.max_file_size.auto_scale()}',\n                    'file_size': file_size,\n                    'limit': self.max_file_size\n                }\n\n            # Check total storage limit\n            projected_total = current_total + file_size\n            if projected_total &gt; self.max_total_size:\n                remaining = self.max_total_size - current_total\n                return {\n                    'valid': False,\n                    'error': 'STORAGE_LIMIT_EXCEEDED',\n                    'message': f'Upload would exceed storage limit. Available: {remaining.auto_scale()}',\n                    'file_size': file_size,\n                    'available': remaining,\n                    'current_usage': current_total\n                }\n\n            return {\n                'valid': True,\n                'file_size': file_size,\n                'current_usage': current_total,\n                'projected_usage': projected_total,\n                'remaining_space': self.max_total_size - projected_total\n            }\n\n        except Exception as e:\n            return {\n                'valid': False,\n                'error': 'VALIDATION_ERROR',\n                'message': f'Could not validate file: {str(e)}'\n            }\n\n    def process_upload(self, source_path: str, filename: str) -&gt; Dict[str, any]:\n        \"\"\"Process file upload with validation and metadata.\"\"\"\n        validation = self.validate_upload(source_path, filename)\n\n        if not validation['valid']:\n            return validation\n\n        try:\n            destination = self.upload_dir / filename\n\n            # Handle filename conflicts\n            counter = 1\n            original_name = destination.stem\n            extension = destination.suffix\n\n            while destination.exists():\n                new_name = f\"{original_name}_{counter}{extension}\"\n                destination = self.upload_dir / new_name\n                counter += 1\n\n            # Copy file\n            shutil.copy2(source_path, destination)\n\n            # Verify successful upload\n            uploaded_size = Storage.get_size_from_path(destination)\n\n            return {\n                'success': True,\n                'filename': destination.name,\n                'file_size': uploaded_size,\n                'file_path': str(destination),\n                'current_usage': validation['projected_usage'],\n                'remaining_space': validation['remaining_space']\n            }\n\n        except Exception as e:\n            return {\n                'success': False,\n                'error': 'UPLOAD_FAILED',\n                'message': f'Upload failed: {str(e)}'\n            }\n\n    def _calculate_current_usage(self) -&gt; Storage:\n        \"\"\"Calculate current storage usage.\"\"\"\n        return Storage.get_size_from_path(self.upload_dir)\n\n    def get_storage_stats(self) -&gt; Dict[str, any]:\n        \"\"\"Get comprehensive storage statistics.\"\"\"\n        current_usage = self._calculate_current_usage()\n        remaining = self.max_total_size - current_usage\n        usage_percent = (current_usage / self.max_total_size) * 100\n\n        files = list(self.upload_dir.glob('*'))\n        file_count = len([f for f in files if f.is_file()])\n\n        return {\n            'total_capacity': self.max_total_size,\n            'current_usage': current_usage,\n            'remaining_space': remaining,\n            'usage_percentage': usage_percent,\n            'file_count': file_count,\n            'max_file_size': self.max_file_size,\n            'status': 'warning' if usage_percent &gt; 80 else 'normal'\n        }\n\n# Usage in a web framework (Flask example)\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\nupload_handler = FileUploadHandler('/uploads', '50 MB', '10 GB')\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return jsonify({'error': 'No file provided'}), 400\n\n    file = request.files['file']\n    if file.filename == '':\n        return jsonify({'error': 'No file selected'}), 400\n\n    # Save temporary file\n    temp_path = f'/tmp/{file.filename}'\n    file.save(temp_path)\n\n    try:\n        result = upload_handler.process_upload(temp_path, file.filename)\n\n        if result.get('success'):\n            return jsonify({\n                'message': 'Upload successful',\n                'filename': result['filename'],\n                'size': str(result['file_size'].auto_scale()),\n                'storage_usage': str(result['current_usage'].auto_scale())\n            })\n        else:\n            return jsonify({\n                'error': result.get('error', 'Unknown error'),\n                'message': result.get('message', 'Upload failed')\n            }), 400\n\n    finally:\n        # Clean up temporary file\n        if os.path.exists(temp_path):\n            os.unlink(temp_path)\n\n@app.route('/storage/stats')\ndef storage_stats():\n    stats = upload_handler.get_storage_stats()\n    return jsonify({\n        'capacity': str(stats['total_capacity'].auto_scale()),\n        'used': str(stats['current_usage'].auto_scale()),\n        'remaining': str(stats['remaining_space'].auto_scale()),\n        'usage_percentage': f\"{stats['usage_percentage']:.1f}%\",\n        'file_count': stats['file_count'],\n        'status': stats['status']\n    })\n</code></pre>"},{"location":"examples/real-world/#content-delivery-network-cdn-analytics","title":"Content Delivery Network (CDN) Analytics","text":"<p>Track and analyze content delivery performance:</p> <pre><code>import json\nimport sqlite3\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Optional\n\nclass CDNAnalyzer:\n    \"\"\"Analyze CDN usage and performance metrics.\"\"\"\n\n    def __init__(self, db_path: str = 'cdn_analytics.db'):\n        self.db_path = db_path\n        self._init_database()\n\n    def _init_database(self):\n        \"\"\"Initialize SQLite database for analytics.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS transfers (\n                id INTEGER PRIMARY KEY,\n                timestamp TEXT,\n                file_path TEXT,\n                file_size_bytes INTEGER,\n                transfer_time_seconds REAL,\n                client_ip TEXT,\n                user_agent TEXT,\n                success BOOLEAN\n            )\n        ''')\n\n        conn.commit()\n        conn.close()\n\n    def log_transfer(self, file_path: str, transfer_time: float, \n                    client_ip: str, user_agent: str, success: bool = True):\n        \"\"\"Log a file transfer event.\"\"\"\n        try:\n            file_size = Storage.get_size_from_path(file_path)\n\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n\n            cursor.execute('''\n                INSERT INTO transfers \n                (timestamp, file_path, file_size_bytes, transfer_time_seconds, \n                 client_ip, user_agent, success)\n                VALUES (?, ?, ?, ?, ?, ?, ?)\n            ''', (\n                datetime.utcnow().isoformat(),\n                file_path,\n                file_size.convert_to_bytes(),\n                transfer_time,\n                client_ip,\n                user_agent,\n                success\n            ))\n\n            conn.commit()\n            conn.close()\n\n        except Exception as e:\n            print(f\"Failed to log transfer: {e}\")\n\n    def analyze_bandwidth_usage(self, days: int = 7) -&gt; Dict[str, any]:\n        \"\"\"Analyze bandwidth usage over specified period.\"\"\"\n        start_date = datetime.utcnow() - timedelta(days=days)\n\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n\n        # Total bandwidth\n        cursor.execute('''\n            SELECT SUM(file_size_bytes), COUNT(*), AVG(transfer_time_seconds)\n            FROM transfers \n            WHERE timestamp &gt; ? AND success = 1\n        ''', (start_date.isoformat(),))\n\n        total_bytes, transfer_count, avg_time = cursor.fetchone()\n\n        if total_bytes is None:\n            total_bytes = 0\n            transfer_count = 0\n            avg_time = 0\n\n        total_bandwidth = Storage.parse_from_bytes(total_bytes)\n\n        # Daily breakdown\n        cursor.execute('''\n            SELECT DATE(timestamp) as date, \n                   SUM(file_size_bytes) as daily_bytes,\n                   COUNT(*) as daily_transfers\n            FROM transfers \n            WHERE timestamp &gt; ? AND success = 1\n            GROUP BY DATE(timestamp)\n            ORDER BY date\n        ''', (start_date.isoformat(),))\n\n        daily_stats = []\n        for date, bytes_transferred, transfers in cursor.fetchall():\n            daily_stats.append({\n                'date': date,\n                'bandwidth': Storage.parse_from_bytes(bytes_transferred),\n                'transfers': transfers,\n                'avg_file_size': Storage.parse_from_bytes(bytes_transferred / transfers) if transfers &gt; 0 else Storage(0, StorageUnit.BYTES)\n            })\n\n        # Top files by bandwidth\n        cursor.execute('''\n            SELECT file_path, \n                   SUM(file_size_bytes) as total_bytes,\n                   COUNT(*) as request_count,\n                   file_size_bytes as file_size\n            FROM transfers \n            WHERE timestamp &gt; ? AND success = 1\n            GROUP BY file_path, file_size_bytes\n            ORDER BY total_bytes DESC\n            LIMIT 10\n        ''', (start_date.isoformat(),))\n\n        top_files = []\n        for file_path, total_bytes, requests, file_size in cursor.fetchall():\n            top_files.append({\n                'file_path': file_path,\n                'total_bandwidth': Storage.parse_from_bytes(total_bytes),\n                'requests': requests,\n                'file_size': Storage.parse_from_bytes(file_size)\n            })\n\n        conn.close()\n\n        # Calculate average throughput\n        avg_throughput = Storage(0, StorageUnit.BYTES)\n        if avg_time &gt; 0:\n            avg_file_size = total_bandwidth / transfer_count if transfer_count &gt; 0 else Storage(0, StorageUnit.BYTES)\n            throughput_bytes_per_second = avg_file_size.convert_to_bytes() / avg_time\n            avg_throughput = Storage.parse_from_bytes(throughput_bytes_per_second)\n\n        return {\n            'period_days': days,\n            'total_bandwidth': total_bandwidth,\n            'total_transfers': transfer_count,\n            'average_throughput': avg_throughput,\n            'daily_stats': daily_stats,\n            'top_files': top_files,\n            'avg_transfer_time': avg_time\n        }\n\n    def generate_report(self, days: int = 7) -&gt; str:\n        \"\"\"Generate human-readable bandwidth report.\"\"\"\n        analysis = self.analyze_bandwidth_usage(days)\n\n        report = f\"CDN Bandwidth Report ({days} days)\\n\"\n        report += \"=\" * 50 + \"\\n\\n\"\n\n        report += f\"\ud83d\udcca Summary:\\n\"\n        report += f\"  Total Bandwidth: {analysis['total_bandwidth'].auto_scale()}\\n\"\n        report += f\"  Total Transfers: {analysis['total_transfers']:,}\\n\"\n        report += f\"  Average Throughput: {analysis['average_throughput'].auto_scale()}/s\\n\"\n        report += f\"  Average Transfer Time: {analysis['avg_transfer_time']:.2f}s\\n\\n\"\n\n        # Daily breakdown\n        if analysis['daily_stats']:\n            report += f\"\ud83d\udcc5 Daily Breakdown:\\n\"\n            for day in analysis['daily_stats']:\n                report += f\"  {day['date']}: {day['bandwidth'].auto_scale()} ({day['transfers']} transfers)\\n\"\n            report += \"\\n\"\n\n        # Top files\n        if analysis['top_files']:\n            report += f\"\ud83d\udd25 Top Files by Bandwidth:\\n\"\n            for i, file_info in enumerate(analysis['top_files'][:5], 1):\n                report += f\"  {i}. {file_info['file_path']}\\n\"\n                report += f\"     Total: {file_info['total_bandwidth'].auto_scale()} ({file_info['requests']} requests)\\n\"\n                report += f\"     Size: {file_info['file_size'].auto_scale()}\\n\"\n\n        return report\n\n# Usage example\nanalyzer = CDNAnalyzer()\n\n# Log some transfers (this would typically be called from your CDN/web server)\nanalyzer.log_transfer('/static/video.mp4', 2.5, '192.168.1.100', 'Mozilla/5.0...')\nanalyzer.log_transfer('/static/image.jpg', 0.1, '192.168.1.101', 'Chrome/100.0...')\n\n# Generate weekly report\nprint(analyzer.generate_report(7))\n</code></pre>"},{"location":"examples/real-world/#system-administration","title":"\ud83d\udda5\ufe0f System Administration","text":""},{"location":"examples/real-world/#disk-space-monitor","title":"Disk Space Monitor","text":"<p>Comprehensive disk space monitoring and alerting:</p> <pre><code>import psutil\nimport smtplib\nfrom email.mime.text import MimeText\nfrom datetime import datetime\nfrom typing import List, Dict, Tuple\n\nclass DiskSpaceMonitor:\n    \"\"\"Production disk space monitoring system.\"\"\"\n\n    def __init__(self, alert_threshold: str = \"90%\", \n                 warning_threshold: str = \"80%\",\n                 email_config: Optional[Dict] = None):\n        self.alert_threshold = float(alert_threshold.rstrip('%'))\n        self.warning_threshold = float(warning_threshold.rstrip('%'))\n        self.email_config = email_config\n        self.last_alerts = {}\n\n    def scan_disk_usage(self) -&gt; List[Dict[str, any]]:\n        \"\"\"Scan all mounted disks and return usage information.\"\"\"\n        disk_info = []\n\n        # Get all disk partitions\n        partitions = psutil.disk_partitions()\n\n        for partition in partitions:\n            try:\n                # Get disk usage statistics\n                usage = psutil.disk_usage(partition.mountpoint)\n\n                total = Storage.parse_from_bytes(usage.total)\n                used = Storage.parse_from_bytes(usage.used)\n                free = Storage.parse_from_bytes(usage.free)\n\n                usage_percent = (used.convert_to_bytes() / total.convert_to_bytes()) * 100\n\n                # Determine status\n                if usage_percent &gt;= self.alert_threshold:\n                    status = 'CRITICAL'\n                elif usage_percent &gt;= self.warning_threshold:\n                    status = 'WARNING'\n                else:\n                    status = 'OK'\n\n                disk_info.append({\n                    'device': partition.device,\n                    'mountpoint': partition.mountpoint,\n                    'filesystem': partition.fstype,\n                    'total': total,\n                    'used': used,\n                    'free': free,\n                    'usage_percent': usage_percent,\n                    'status': status\n                })\n\n            except PermissionError:\n                # Skip inaccessible partitions\n                continue\n            except Exception as e:\n                print(f\"Error scanning {partition.mountpoint}: {e}\")\n                continue\n\n        return disk_info\n\n    def check_large_directories(self, paths: List[str], \n                               threshold: str = \"1 GB\") -&gt; List[Dict[str, any]]:\n        \"\"\"Check specified directories for large size.\"\"\"\n        threshold_size = Storage.parse(threshold)\n        large_dirs = []\n\n        for path in paths:\n            try:\n                dir_size = Storage.get_size_from_path(path)\n\n                if dir_size &gt; threshold_size:\n                    large_dirs.append({\n                        'path': path,\n                        'size': dir_size,\n                        'threshold': threshold_size,\n                        'over_threshold': dir_size - threshold_size\n                    })\n\n            except (FileNotFoundError, PermissionError) as e:\n                large_dirs.append({\n                    'path': path,\n                    'error': str(e),\n                    'size': None\n                })\n\n        return large_dirs\n\n    def find_largest_files(self, directory: str, \n                          count: int = 10) -&gt; List[Tuple[str, Storage]]:\n        \"\"\"Find the largest files in a directory.\"\"\"\n        file_sizes = []\n\n        try:\n            for file_path in Path(directory).rglob('*'):\n                if file_path.is_file():\n                    try:\n                        size = Storage.get_size_from_path(file_path)\n                        file_sizes.append((str(file_path), size))\n                    except (PermissionError, FileNotFoundError):\n                        continue\n\n            # Sort by size and return top N\n            file_sizes.sort(key=lambda x: x[1].convert_to_bytes(), reverse=True)\n            return file_sizes[:count]\n\n        except Exception as e:\n            print(f\"Error scanning directory {directory}: {e}\")\n            return []\n\n    def generate_alert_report(self, disk_info: List[Dict], \n                            large_dirs: List[Dict] = None,\n                            largest_files: List[Tuple] = None) -&gt; str:\n        \"\"\"Generate comprehensive alert report.\"\"\"\n        report = f\"\ud83d\udea8 Disk Space Alert Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\"\n        report += \"=\" * 70 + \"\\n\\n\"\n\n        # Critical and warning disks\n        critical_disks = [disk for disk in disk_info if disk['status'] == 'CRITICAL']\n        warning_disks = [disk for disk in disk_info if disk['status'] == 'WARNING']\n\n        if critical_disks:\n            report += \"\ud83d\udd34 CRITICAL DISK USAGE:\\n\"\n            for disk in critical_disks:\n                report += f\"  {disk['device']} ({disk['mountpoint']})\\n\"\n                report += f\"    Usage: {disk['usage_percent']:.1f}% ({disk['used'].auto_scale()} / {disk['total'].auto_scale()})\\n\"\n                report += f\"    Free: {disk['free'].auto_scale()}\\n\"\n                report += f\"    Filesystem: {disk['filesystem']}\\n\\n\"\n\n        if warning_disks:\n            report += \"\ud83d\udfe1 WARNING DISK USAGE:\\n\"\n            for disk in warning_disks:\n                report += f\"  {disk['device']} ({disk['mountpoint']})\\n\"\n                report += f\"    Usage: {disk['usage_percent']:.1f}% ({disk['used'].auto_scale()} / {disk['total'].auto_scale()})\\n\"\n                report += f\"    Free: {disk['free'].auto_scale()}\\n\\n\"\n\n        # Large directories\n        if large_dirs:\n            report += \"\ud83d\udcc1 LARGE DIRECTORIES:\\n\"\n            for dir_info in large_dirs:\n                if 'error' not in dir_info:\n                    report += f\"  {dir_info['path']}: {dir_info['size'].auto_scale()}\\n\"\n                    report += f\"    Over threshold by: {dir_info['over_threshold'].auto_scale()}\\n\"\n                else:\n                    report += f\"  {dir_info['path']}: Error - {dir_info['error']}\\n\"\n            report += \"\\n\"\n\n        # Largest files\n        if largest_files:\n            report += \"\ud83d\udcc4 LARGEST FILES:\\n\"\n            for i, (file_path, size) in enumerate(largest_files[:10], 1):\n                report += f\"  {i:2d}. {size.auto_scale():&gt;8} - {file_path}\\n\"\n            report += \"\\n\"\n\n        # Summary\n        total_disks = len(disk_info)\n        ok_disks = len([d for d in disk_info if d['status'] == 'OK'])\n\n        report += f\"\ud83d\udcca SUMMARY:\\n\"\n        report += f\"  Total Partitions: {total_disks}\\n\"\n        report += f\"  OK: {ok_disks}, Warning: {len(warning_disks)}, Critical: {len(critical_disks)}\\n\"\n\n        return report\n\n    def send_email_alert(self, subject: str, body: str):\n        \"\"\"Send email alert if configured.\"\"\"\n        if not self.email_config:\n            return False\n\n        try:\n            msg = MimeText(body)\n            msg['Subject'] = subject\n            msg['From'] = self.email_config['from']\n            msg['To'] = ', '.join(self.email_config['to'])\n\n            with smtplib.SMTP(self.email_config['smtp_host'], \n                            self.email_config['smtp_port']) as server:\n                if self.email_config.get('use_tls'):\n                    server.starttls()\n                if self.email_config.get('username'):\n                    server.login(self.email_config['username'], \n                               self.email_config['password'])\n\n                server.send_message(msg)\n\n            return True\n\n        except Exception as e:\n            print(f\"Failed to send email alert: {e}\")\n            return False\n\n    def run_monitoring_cycle(self, check_dirs: List[str] = None):\n        \"\"\"Run complete monitoring cycle.\"\"\"\n        print(f\"\ud83d\udd0d Starting disk monitoring cycle at {datetime.now()}\")\n\n        # Scan disk usage\n        disk_info = self.scan_disk_usage()\n\n        # Check for alerts\n        alerts_needed = any(disk['status'] in ['CRITICAL', 'WARNING'] \n                          for disk in disk_info)\n\n        # Check large directories if specified\n        large_dirs = None\n        if check_dirs:\n            large_dirs = self.check_large_directories(check_dirs)\n\n        # Find largest files in problematic partitions\n        largest_files = []\n        for disk in disk_info:\n            if disk['status'] == 'CRITICAL':\n                files = self.find_largest_files(disk['mountpoint'], 5)\n                largest_files.extend(files)\n\n        # Generate report\n        report = self.generate_alert_report(disk_info, large_dirs, largest_files)\n\n        # Print report\n        print(report)\n\n        # Send email alerts if needed\n        if alerts_needed and self.email_config:\n            critical_count = len([d for d in disk_info if d['status'] == 'CRITICAL'])\n            warning_count = len([d for d in disk_info if d['status'] == 'WARNING'])\n\n            subject = f\"\ud83d\udea8 Disk Space Alert: {critical_count} Critical, {warning_count} Warning\"\n            self.send_email_alert(subject, report)\n\n        return {\n            'disk_info': disk_info,\n            'large_dirs': large_dirs,\n            'largest_files': largest_files,\n            'alerts_sent': alerts_needed\n        }\n\n# Usage example\nemail_config = {\n    'smtp_host': 'smtp.gmail.com',\n    'smtp_port': 587,\n    'use_tls': True,\n    'username': 'alerts@company.com',\n    'password': 'app_password',\n    'from': 'alerts@company.com',\n    'to': ['admin@company.com', 'ops@company.com']\n}\n\nmonitor = DiskSpaceMonitor(\n    alert_threshold=\"90%\",\n    warning_threshold=\"80%\",\n    email_config=email_config\n)\n\n# Run monitoring\nresult = monitor.run_monitoring_cycle([\n    '/var/log',\n    '/tmp',\n    '/home/users',\n    '/opt/applications'\n])\n</code></pre>"},{"location":"examples/real-world/#data-analysis-and-etl","title":"\ud83d\udcca Data Analysis and ETL","text":""},{"location":"examples/real-world/#log-file-analyzer","title":"Log File Analyzer","text":"<p>Analyze log files and track storage patterns:</p> <pre><code>import re\nimport gzip\nfrom collections import defaultdict, Counter\nfrom datetime import datetime, timedelta\nfrom typing import Iterator, Dict, List, Tuple\n\nclass LogFileAnalyzer:\n    \"\"\"Analyze log files for storage and performance patterns.\"\"\"\n\n    def __init__(self, log_pattern: str = None):\n        # Default Apache/Nginx log pattern\n        self.log_pattern = log_pattern or (\n            r'(?P&lt;ip&gt;\\S+) \\S+ \\S+ \\[(?P&lt;timestamp&gt;[^\\]]+)\\] '\n            r'\"(?P&lt;method&gt;\\S+) (?P&lt;url&gt;\\S+) \\S+\" (?P&lt;status&gt;\\d+) '\n            r'(?P&lt;size&gt;\\d+|-) \"(?P&lt;referer&gt;[^\"]*)\" \"(?P&lt;user_agent&gt;[^\"]*)\"'\n        )\n        self.log_regex = re.compile(self.log_pattern)\n\n    def parse_log_file(self, file_path: str) -&gt; Iterator[Dict[str, any]]:\n        \"\"\"Parse log file and yield structured records.\"\"\"\n        open_func = gzip.open if file_path.endswith('.gz') else open\n\n        with open_func(file_path, 'rt', encoding='utf-8', errors='ignore') as f:\n            for line_num, line in enumerate(f, 1):\n                try:\n                    match = self.log_regex.match(line.strip())\n                    if match:\n                        data = match.groupdict()\n\n                        # Parse size\n                        size_str = data.get('size', '0')\n                        if size_str == '-' or size_str == '':\n                            size = Storage(0, StorageUnit.BYTES)\n                        else:\n                            size = Storage(int(size_str), StorageUnit.BYTES)\n\n                        # Parse timestamp\n                        timestamp_str = data.get('timestamp', '')\n                        try:\n                            # Common log format: 10/Oct/2000:13:55:36 -0700\n                            timestamp = datetime.strptime(\n                                timestamp_str.split()[0], \n                                '%d/%b/%Y:%H:%M:%S'\n                            )\n                        except ValueError:\n                            timestamp = datetime.now()\n\n                        yield {\n                            'line_number': line_num,\n                            'ip': data.get('ip', ''),\n                            'timestamp': timestamp,\n                            'method': data.get('method', ''),\n                            'url': data.get('url', ''),\n                            'status': int(data.get('status', 0)),\n                            'size': size,\n                            'referer': data.get('referer', ''),\n                            'user_agent': data.get('user_agent', ''),\n                            'raw_line': line.strip()\n                        }\n\n                except Exception as e:\n                    # Skip malformed lines but track them\n                    yield {\n                        'line_number': line_num,\n                        'error': str(e),\n                        'raw_line': line.strip()\n                    }\n\n    def analyze_bandwidth_usage(self, file_paths: List[str], \n                               time_window: int = 24) -&gt; Dict[str, any]:\n        \"\"\"Analyze bandwidth usage patterns.\"\"\"\n        hourly_bandwidth = defaultdict(lambda: Storage(0, StorageUnit.BYTES))\n        status_bandwidth = defaultdict(lambda: Storage(0, StorageUnit.BYTES))\n        url_bandwidth = defaultdict(lambda: Storage(0, StorageUnit.BYTES))\n        ip_bandwidth = defaultdict(lambda: Storage(0, StorageUnit.BYTES))\n\n        total_bandwidth = Storage(0, StorageUnit.BYTES)\n        total_requests = 0\n        error_count = 0\n\n        # Cutoff time for analysis window\n        cutoff_time = datetime.now() - timedelta(hours=time_window)\n\n        for file_path in file_paths:\n            print(f\"Analyzing {file_path}...\")\n\n            for record in self.parse_log_file(file_path):\n                if 'error' in record:\n                    error_count += 1\n                    continue\n\n                # Skip records outside time window\n                if record['timestamp'] &lt; cutoff_time:\n                    continue\n\n                size = record['size']\n                total_bandwidth += size\n                total_requests += 1\n\n                # Hourly breakdown\n                hour_key = record['timestamp'].strftime('%Y-%m-%d %H:00')\n                hourly_bandwidth[hour_key] += size\n\n                # Status code breakdown\n                status_code = record['status']\n                status_bandwidth[f\"{status_code}\"] += size\n\n                # Top URLs by bandwidth\n                url_bandwidth[record['url']] += size\n\n                # Top IPs by bandwidth\n                ip_bandwidth[record['ip']] += size\n\n        # Calculate averages and top items\n        avg_request_size = (total_bandwidth / total_requests \n                           if total_requests &gt; 0 \n                           else Storage(0, StorageUnit.BYTES))\n\n        # Sort top consumers\n        top_urls = sorted(url_bandwidth.items(), \n                         key=lambda x: x[1].convert_to_bytes(), \n                         reverse=True)[:20]\n\n        top_ips = sorted(ip_bandwidth.items(),\n                        key=lambda x: x[1].convert_to_bytes(),\n                        reverse=True)[:20]\n\n        return {\n            'analysis_period_hours': time_window,\n            'total_bandwidth': total_bandwidth,\n            'total_requests': total_requests,\n            'average_request_size': avg_request_size,\n            'parsing_errors': error_count,\n            'hourly_bandwidth': dict(hourly_bandwidth),\n            'status_bandwidth': dict(status_bandwidth),\n            'top_urls': top_urls,\n            'top_ips': top_ips\n        }\n\n    def generate_bandwidth_report(self, analysis: Dict[str, any]) -&gt; str:\n        \"\"\"Generate human-readable bandwidth report.\"\"\"\n        report = f\"\ud83d\udcc8 Bandwidth Analysis Report\\n\"\n        report += f\"Analysis Period: {analysis['analysis_period_hours']} hours\\n\"\n        report += \"=\" * 60 + \"\\n\\n\"\n\n        # Summary statistics\n        report += f\"\ud83d\udcca Summary:\\n\"\n        report += f\"  Total Bandwidth: {analysis['total_bandwidth'].auto_scale()}\\n\"\n        report += f\"  Total Requests: {analysis['total_requests']:,}\\n\"\n        report += f\"  Average Request Size: {analysis['average_request_size'].auto_scale()}\\n\"\n        report += f\"  Parsing Errors: {analysis['parsing_errors']:,}\\n\\n\"\n\n        # Status code breakdown\n        if analysis['status_bandwidth']:\n            report += f\"\ud83d\udccb Bandwidth by Status Code:\\n\"\n            for status, bandwidth in sorted(analysis['status_bandwidth'].items()):\n                percentage = (bandwidth / analysis['total_bandwidth']) * 100\n                report += f\"  {status}: {bandwidth.auto_scale()} ({percentage:.1f}%)\\n\"\n            report += \"\\n\"\n\n        # Top URLs\n        if analysis['top_urls']:\n            report += f\"\ud83d\udd25 Top URLs by Bandwidth:\\n\"\n            for i, (url, bandwidth) in enumerate(analysis['top_urls'][:10], 1):\n                percentage = (bandwidth / analysis['total_bandwidth']) * 100\n                report += f\"  {i:2d}. {bandwidth.auto_scale():&gt;8} ({percentage:4.1f}%) - {url}\\n\"\n            report += \"\\n\"\n\n        # Top IPs\n        if analysis['top_ips']:\n            report += f\"\ud83c\udf10 Top IPs by Bandwidth:\\n\"\n            for i, (ip, bandwidth) in enumerate(analysis['top_ips'][:10], 1):\n                percentage = (bandwidth / analysis['total_bandwidth']) * 100\n                report += f\"  {i:2d}. {bandwidth.auto_scale():&gt;8} ({percentage:4.1f}%) - {ip}\\n\"\n            report += \"\\n\"\n\n        # Hourly breakdown (last 24 hours)\n        if analysis['hourly_bandwidth']:\n            report += f\"\u23f0 Hourly Bandwidth (Last 24 Hours):\\n\"\n            sorted_hours = sorted(analysis['hourly_bandwidth'].items())\n            for hour, bandwidth in sorted_hours[-24:]:\n                report += f\"  {hour}: {bandwidth.auto_scale()}\\n\"\n\n        return report\n\n    def detect_anomalies(self, analysis: Dict[str, any]) -&gt; List[Dict[str, any]]:\n        \"\"\"Detect bandwidth usage anomalies.\"\"\"\n        anomalies = []\n\n        # Check for unusually large requests\n        avg_size = analysis['average_request_size']\n        large_request_threshold = avg_size * 10  # 10x average\n\n        for url, bandwidth in analysis['top_urls']:\n            # Estimate request count (rough)\n            estimated_requests = bandwidth / avg_size if avg_size.convert_to_bytes() &gt; 0 else 1\n            avg_per_request = bandwidth / estimated_requests\n\n            if avg_per_request &gt; large_request_threshold:\n                anomalies.append({\n                    'type': 'large_requests',\n                    'url': url,\n                    'bandwidth': bandwidth,\n                    'estimated_avg_size': avg_per_request,\n                    'threshold': large_request_threshold\n                })\n\n        # Check for high-bandwidth IPs\n        total_bandwidth = analysis['total_bandwidth']\n        high_usage_threshold = total_bandwidth * 0.1  # 10% of total\n\n        for ip, bandwidth in analysis['top_ips']:\n            if bandwidth &gt; high_usage_threshold:\n                percentage = (bandwidth / total_bandwidth) * 100\n                anomalies.append({\n                    'type': 'high_bandwidth_ip',\n                    'ip': ip,\n                    'bandwidth': bandwidth,\n                    'percentage': percentage\n                })\n\n        return anomalies\n\n# Usage example\nanalyzer = LogFileAnalyzer()\n\n# Analyze recent logs\nlog_files = [\n    '/var/log/nginx/access.log',\n    '/var/log/nginx/access.log.1',\n    '/var/log/apache2/access.log'\n]\n\ntry:\n    analysis = analyzer.analyze_bandwidth_usage(log_files, time_window=24)\n    report = analyzer.generate_bandwidth_report(analysis)\n    print(report)\n\n    # Check for anomalies\n    anomalies = analyzer.detect_anomalies(analysis)\n    if anomalies:\n        print(\"\\n\ud83d\udea8 Detected Anomalies:\")\n        for anomaly in anomalies:\n            if anomaly['type'] == 'large_requests':\n                print(f\"  Large requests to {anomaly['url']}: {anomaly['bandwidth'].auto_scale()}\")\n            elif anomaly['type'] == 'high_bandwidth_ip':\n                print(f\"  High bandwidth IP {anomaly['ip']}: {anomaly['bandwidth'].auto_scale()} ({anomaly['percentage']:.1f}%)\")\n\nexcept Exception as e:\n    print(f\"Analysis failed: {e}\")\n</code></pre>"},{"location":"examples/real-world/#gaming-and-media","title":"\ud83c\udfae Gaming and Media","text":""},{"location":"examples/real-world/#game-asset-manager","title":"Game Asset Manager","text":"<p>Manage game assets and optimize storage:</p> <pre><code>import hashlib\nfrom pathlib import Path\nfrom typing import Dict, List, Set, Optional, Tuple\n\nclass GameAssetManager:\n    \"\"\"Manage game assets with storage optimization.\"\"\"\n\n    def __init__(self, assets_dir: str, cache_dir: str = None):\n        self.assets_dir = Path(assets_dir)\n        self.cache_dir = Path(cache_dir) if cache_dir else self.assets_dir / '.cache'\n        self.cache_dir.mkdir(exist_ok=True)\n\n        # Asset categories with typical sizes\n        self.asset_categories = {\n            'textures': ['.png', '.jpg', '.jpeg', '.tga', '.dds', '.exr'],\n            'models': ['.fbx', '.obj', '.dae', '.gltf', '.glb'],\n            'audio': ['.wav', '.mp3', '.ogg', '.flac', '.aiff'],\n            'video': ['.mp4', '.mov', '.avi', '.webm'],\n            'scripts': ['.cs', '.js', '.lua', '.py'],\n            'shaders': ['.hlsl', '.glsl', '.cg', '.shader'],\n            'data': ['.json', '.xml', '.yaml', '.csv']\n        }\n\n    def scan_assets(self) -&gt; Dict[str, any]:\n        \"\"\"Scan all assets and categorize by type.\"\"\"\n        asset_info = {\n            'categories': {},\n            'total_size': Storage(0, StorageUnit.BYTES),\n            'total_files': 0,\n            'duplicates': [],\n            'large_files': [],\n            'optimization_suggestions': []\n        }\n\n        # Initialize category tracking\n        for category in self.asset_categories:\n            asset_info['categories'][category] = {\n                'files': [],\n                'total_size': Storage(0, StorageUnit.BYTES),\n                'file_count': 0\n            }\n\n        asset_info['categories']['other'] = {\n            'files': [],\n            'total_size': Storage(0, StorageUnit.BYTES),\n            'file_count': 0\n        }\n\n        # File hash tracking for duplicate detection\n        file_hashes = {}\n\n        # Scan all files\n        for file_path in self.assets_dir.rglob('*'):\n            if file_path.is_file():\n                try:\n                    file_size = Storage.get_size_from_path(file_path)\n                    asset_info['total_size'] += file_size\n                    asset_info['total_files'] += 1\n\n                    # Categorize file\n                    category = self._categorize_file(file_path)\n\n                    file_info = {\n                        'path': str(file_path.relative_to(self.assets_dir)),\n                        'size': file_size,\n                        'extension': file_path.suffix.lower()\n                    }\n\n                    asset_info['categories'][category]['files'].append(file_info)\n                    asset_info['categories'][category]['total_size'] += file_size\n                    asset_info['categories'][category]['file_count'] += 1\n\n                    # Check for large files (&gt;50MB)\n                    if file_size &gt; Storage(50, StorageUnit.MB):\n                        asset_info['large_files'].append(file_info)\n\n                    # Calculate hash for duplicate detection\n                    file_hash = self._calculate_file_hash(file_path)\n                    if file_hash in file_hashes:\n                        # Found duplicate\n                        original_file = file_hashes[file_hash]\n                        asset_info['duplicates'].append({\n                            'original': original_file,\n                            'duplicate': file_info,\n                            'wasted_space': file_size\n                        })\n                    else:\n                        file_hashes[file_hash] = file_info\n\n                except Exception as e:\n                    print(f\"Error processing {file_path}: {e}\")\n                    continue\n\n        # Generate optimization suggestions\n        asset_info['optimization_suggestions'] = self._generate_optimization_suggestions(asset_info)\n\n        return asset_info\n\n    def _categorize_file(self, file_path: Path) -&gt; str:\n        \"\"\"Categorize file based on extension.\"\"\"\n        extension = file_path.suffix.lower()\n\n        for category, extensions in self.asset_categories.items():\n            if extension in extensions:\n                return category\n\n        return 'other'\n\n    def _calculate_file_hash(self, file_path: Path) -&gt; str:\n        \"\"\"Calculate MD5 hash of file for duplicate detection.\"\"\"\n        hash_md5 = hashlib.md5()\n        try:\n            with open(file_path, \"rb\") as f:\n                for chunk in iter(lambda: f.read(4096), b\"\"):\n                    hash_md5.update(chunk)\n            return hash_md5.hexdigest()\n        except Exception:\n            return f\"error_{file_path.name}\"\n\n    def _generate_optimization_suggestions(self, asset_info: Dict) -&gt; List[Dict[str, any]]:\n        \"\"\"Generate optimization suggestions based on asset analysis.\"\"\"\n        suggestions = []\n\n        # Check for excessive texture sizes\n        texture_category = asset_info['categories']['textures']\n        if texture_category['total_size'] &gt; Storage(1, StorageUnit.GB):\n            large_textures = [f for f in texture_category['files'] \n                            if f['size'] &gt; Storage(10, StorageUnit.MB)]\n            if large_textures:\n                suggestions.append({\n                    'type': 'texture_optimization',\n                    'severity': 'medium',\n                    'description': f\"Found {len(large_textures)} large textures (&gt;10MB)\",\n                    'potential_savings': sum(f['size'] for f in large_textures) * 0.3,  # Estimate 30% compression\n                    'action': 'Consider compressing textures or using lower resolution versions'\n                })\n\n        # Check for duplicate files\n        if asset_info['duplicates']:\n            total_wasted = sum(dup['wasted_space'] for dup in asset_info['duplicates'])\n            suggestions.append({\n                'type': 'duplicate_removal',\n                'severity': 'high',\n                'description': f\"Found {len(asset_info['duplicates'])} duplicate files\",\n                'potential_savings': total_wasted,\n                'action': 'Remove duplicate files to save space'\n            })\n\n        # Check for uncompressed audio\n        audio_category = asset_info['categories']['audio']\n        wav_files = [f for f in audio_category['files'] if f['extension'] == '.wav']\n        if wav_files and len(wav_files) &gt; 10:\n            wav_size = sum(f['size'] for f in wav_files)\n            suggestions.append({\n                'type': 'audio_compression',\n                'severity': 'medium',\n                'description': f\"Found {len(wav_files)} uncompressed WAV files\",\n                'potential_savings': wav_size * 0.7,  # Estimate 70% compression\n                'action': 'Convert WAV files to OGG or MP3 for better compression'\n            })\n\n        return suggestions\n\n    def generate_asset_report(self, asset_info: Dict) -&gt; str:\n        \"\"\"Generate comprehensive asset report.\"\"\"\n        report = \"\ud83c\udfae Game Asset Analysis Report\\n\"\n        report += \"=\" * 50 + \"\\n\\n\"\n\n        # Summary\n        report += f\"\ud83d\udcca Summary:\\n\"\n        report += f\"  Total Assets: {asset_info['total_files']:,} files\\n\"\n        report += f\"  Total Size: {asset_info['total_size'].auto_scale()}\\n\"\n        report += f\"  Duplicates: {len(asset_info['duplicates'])}\\n\"\n        report += f\"  Large Files (&gt;50MB): {len(asset_info['large_files'])}\\n\\n\"\n\n        # Category breakdown\n        report += f\"\ud83d\udcc1 Asset Categories:\\n\"\n        for category, info in asset_info['categories'].items():\n            if info['file_count'] &gt; 0:\n                percentage = (info['total_size'] / asset_info['total_size']) * 100\n                avg_size = info['total_size'] / info['file_count']\n                report += f\"  {category.title()}:\\n\"\n                report += f\"    Files: {info['file_count']:,}\\n\"\n                report += f\"    Size: {info['total_size'].auto_scale()} ({percentage:.1f}%)\\n\"\n                report += f\"    Avg Size: {avg_size.auto_scale()}\\n\"\n        report += \"\\n\"\n\n        # Large files\n        if asset_info['large_files']:\n            report += f\"\ud83d\udd0d Large Files (&gt;50MB):\\n\"\n            sorted_large = sorted(asset_info['large_files'], \n                                key=lambda x: x['size'].convert_to_bytes(), \n                                reverse=True)\n            for file_info in sorted_large[:10]:\n                report += f\"  {file_info['size'].auto_scale():&gt;8} - {file_info['path']}\\n\"\n            report += \"\\n\"\n\n        # Duplicates\n        if asset_info['duplicates']:\n            total_wasted = sum(dup['wasted_space'] for dup in asset_info['duplicates'])\n            report += f\"\ud83d\udd04 Duplicate Files ({len(asset_info['duplicates'])} pairs):\\n\"\n            report += f\"  Wasted Space: {total_wasted.auto_scale()}\\n\"\n            for dup in asset_info['duplicates'][:5]:\n                report += f\"    {dup['duplicate']['size'].auto_scale()} - {dup['original']['path']} = {dup['duplicate']['path']}\\n\"\n            if len(asset_info['duplicates']) &gt; 5:\n                report += f\"    ... and {len(asset_info['duplicates']) - 5} more\\n\"\n            report += \"\\n\"\n\n        # Optimization suggestions\n        if asset_info['optimization_suggestions']:\n            report += f\"\ud83d\udca1 Optimization Suggestions:\\n\"\n            total_potential_savings = Storage(0, StorageUnit.BYTES)\n\n            for suggestion in asset_info['optimization_suggestions']:\n                severity_icon = {'high': '\ud83d\udd34', 'medium': '\ud83d\udfe1', 'low': '\ud83d\udfe2'}.get(suggestion['severity'], '\ud83d\udd35')\n                potential_savings = suggestion['potential_savings']\n                total_potential_savings += potential_savings\n\n                report += f\"  {severity_icon} {suggestion['description']}\\n\"\n                report += f\"    Potential Savings: {potential_savings.auto_scale()}\\n\"\n                report += f\"    Action: {suggestion['action']}\\n\"\n\n            report += f\"\\n  \ud83d\udcb0 Total Potential Savings: {total_potential_savings.auto_scale()}\\n\"\n\n        return report\n\n    def optimize_duplicates(self, dry_run: bool = True) -&gt; Dict[str, any]:\n        \"\"\"Remove or hardlink duplicate files.\"\"\"\n        asset_info = self.scan_assets()\n        duplicates = asset_info['duplicates']\n\n        if not duplicates:\n            return {'removed': 0, 'space_saved': Storage(0, StorageUnit.BYTES)}\n\n        removed_count = 0\n        space_saved = Storage(0, StorageUnit.BYTES)\n\n        for duplicate in duplicates:\n            duplicate_path = self.assets_dir / duplicate['duplicate']['path']\n\n            if dry_run:\n                print(f\"Would remove: {duplicate_path}\")\n                removed_count += 1\n                space_saved += duplicate['wasted_space']\n            else:\n                try:\n                    duplicate_path.unlink()\n                    print(f\"Removed: {duplicate_path}\")\n                    removed_count += 1\n                    space_saved += duplicate['wasted_space']\n                except Exception as e:\n                    print(f\"Failed to remove {duplicate_path}: {e}\")\n\n        return {\n            'removed': removed_count,\n            'space_saved': space_saved,\n            'dry_run': dry_run\n        }\n\n# Usage example\nasset_manager = GameAssetManager('./game_assets')\n\n# Scan and analyze assets\nprint(\"\ud83d\udd0d Scanning game assets...\")\nasset_info = asset_manager.scan_assets()\n\n# Generate report\nreport = asset_manager.generate_asset_report(asset_info)\nprint(report)\n\n# Optimize duplicates (dry run first)\nprint(\"\\n\ud83d\udd27 Checking for duplicate optimization...\")\noptimization_result = asset_manager.optimize_duplicates(dry_run=True)\nprint(f\"Could save {optimization_result['space_saved'].auto_scale()} by removing {optimization_result['removed']} duplicates\")\n</code></pre>"},{"location":"examples/real-world/#security-and-compliance","title":"\ud83d\udd10 Security and Compliance","text":""},{"location":"examples/real-world/#data-retention-monitor","title":"Data Retention Monitor","text":"<p>Monitor and enforce data retention policies:</p> <pre><code>import json\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple\n\nclass DataRetentionMonitor:\n    \"\"\"Monitor and enforce data retention policies.\"\"\"\n\n    def __init__(self, config_file: str = 'retention_policies.json'):\n        self.config_file = config_file\n        self.policies = self._load_policies()\n\n    def _load_policies(self) -&gt; Dict[str, any]:\n        \"\"\"Load retention policies from configuration file.\"\"\"\n        default_policies = {\n            'log_files': {\n                'paths': ['/var/log/**/*.log', '/opt/app/logs/**/*.log'],\n                'retention_days': 90,\n                'size_threshold': '10 GB',\n                'compress_after_days': 7,\n                'archive_location': '/archive/logs'\n            },\n            'user_uploads': {\n                'paths': ['/uploads/**/*'],\n                'retention_days': 365,\n                'size_threshold': '100 GB',\n                'compress_after_days': 30,\n                'archive_location': '/archive/uploads'\n            },\n            'temp_files': {\n                'paths': ['/tmp/**/*', '/var/tmp/**/*'],\n                'retention_days': 7,\n                'size_threshold': '1 GB',\n                'compress_after_days': 1,\n                'archive_location': None  # Delete, don't archive\n            },\n            'database_backups': {\n                'paths': ['/backups/db/**/*.sql', '/backups/db/**/*.dump'],\n                'retention_days': 30,\n                'size_threshold': '50 GB',\n                'compress_after_days': 1,\n                'archive_location': '/archive/backups'\n            }\n        }\n\n        try:\n            if Path(self.config_file).exists():\n                with open(self.config_file, 'r') as f:\n                    return json.load(f)\n            else:\n                # Create default config file\n                with open(self.config_file, 'w') as f:\n                    json.dump(default_policies, f, indent=2)\n                return default_policies\n        except Exception as e:\n            print(f\"Error loading policies: {e}, using defaults\")\n            return default_policies\n\n    def scan_policy_violations(self) -&gt; Dict[str, any]:\n        \"\"\"Scan for files violating retention policies.\"\"\"\n        violations = {\n            'expired_files': [],\n            'oversized_directories': [],\n            'compression_candidates': [],\n            'total_violations': 0,\n            'total_recoverable_space': Storage(0, StorageUnit.BYTES)\n        }\n\n        for policy_name, policy in self.policies.items():\n            print(f\"Checking policy: {policy_name}\")\n\n            retention_cutoff = datetime.now() - timedelta(days=policy['retention_days'])\n            compression_cutoff = datetime.now() - timedelta(days=policy['compress_after_days'])\n            size_threshold = Storage.parse(policy['size_threshold'])\n\n            # Check each path pattern\n            for path_pattern in policy['paths']:\n                try:\n                    # Use glob to find matching files\n                    from glob import glob\n                    matching_paths = glob(path_pattern, recursive=True)\n\n                    for file_path in matching_paths:\n                        file_path = Path(file_path)\n\n                        if not file_path.exists() or not file_path.is_file():\n                            continue\n\n                        try:\n                            file_size = Storage.get_size_from_path(file_path)\n                            file_mtime = datetime.fromtimestamp(file_path.stat().st_mtime)\n\n                            # Check for expired files\n                            if file_mtime &lt; retention_cutoff:\n                                violations['expired_files'].append({\n                                    'policy': policy_name,\n                                    'path': str(file_path),\n                                    'size': file_size,\n                                    'age_days': (datetime.now() - file_mtime).days,\n                                    'action': 'archive' if policy['archive_location'] else 'delete'\n                                })\n                                violations['total_recoverable_space'] += file_size\n\n                            # Check for compression candidates\n                            elif (file_mtime &lt; compression_cutoff and \n                                  not str(file_path).endswith(('.gz', '.zip', '.bz2')) and\n                                  file_size &gt; Storage(1, StorageUnit.MB)):\n\n                                violations['compression_candidates'].append({\n                                    'policy': policy_name,\n                                    'path': str(file_path),\n                                    'size': file_size,\n                                    'age_days': (datetime.now() - file_mtime).days,\n                                    'estimated_compressed_size': file_size * 0.3  # Estimate 70% compression\n                                })\n\n                        except Exception as e:\n                            print(f\"Error processing {file_path}: {e}\")\n                            continue\n\n                except Exception as e:\n                    print(f\"Error processing pattern {path_pattern}: {e}\")\n                    continue\n\n            # Check directory sizes\n            for path_pattern in policy['paths']:\n                try:\n                    # Get parent directories to check\n                    parent_dirs = set()\n                    for path in glob(path_pattern, recursive=True):\n                        parent_dirs.add(str(Path(path).parent))\n\n                    for dir_path in parent_dirs:\n                        try:\n                            dir_size = Storage.get_size_from_path(dir_path)\n\n                            if dir_size &gt; size_threshold:\n                                violations['oversized_directories'].append({\n                                    'policy': policy_name,\n                                    'path': dir_path,\n                                    'size': dir_size,\n                                    'threshold': size_threshold,\n                                    'overage': dir_size - size_threshold\n                                })\n\n                        except Exception as e:\n                            print(f\"Error checking directory {dir_path}: {e}\")\n                            continue\n\n                except Exception as e:\n                    print(f\"Error checking directories for {path_pattern}: {e}\")\n                    continue\n\n        violations['total_violations'] = (\n            len(violations['expired_files']) + \n            len(violations['oversized_directories']) + \n            len(violations['compression_candidates'])\n        )\n\n        return violations\n\n    def generate_compliance_report(self, violations: Dict[str, any]) -&gt; str:\n        \"\"\"Generate data retention compliance report.\"\"\"\n        report = \"\ud83d\udd10 Data Retention Compliance Report\\n\"\n        report += f\"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\"\n        report += \"=\" * 60 + \"\\n\\n\"\n\n        # Summary\n        report += f\"\ud83d\udcca Summary:\\n\"\n        report += f\"  Total Violations: {violations['total_violations']}\\n\"\n        report += f\"  Expired Files: {len(violations['expired_files'])}\\n\"\n        report += f\"  Oversized Directories: {len(violations['oversized_directories'])}\\n\"\n        report += f\"  Compression Candidates: {len(violations['compression_candidates'])}\\n\"\n        report += f\"  Recoverable Space: {violations['total_recoverable_space'].auto_scale()}\\n\\n\"\n\n        # Expired files\n        if violations['expired_files']:\n            report += f\"\ud83d\uddd1\ufe0f  Expired Files (Retention Policy Violated):\\n\"\n\n            # Group by policy\n            by_policy = {}\n            for violation in violations['expired_files']:\n                policy = violation['policy']\n                if policy not in by_policy:\n                    by_policy[policy] = []\n                by_policy[policy].append(violation)\n\n            for policy_name, policy_violations in by_policy.items():\n                total_size = sum(v['size'] for v in policy_violations)\n                report += f\"  {policy_name} ({len(policy_violations)} files, {total_size.auto_scale()}):\\n\"\n\n                # Show top 5 largest files\n                sorted_violations = sorted(policy_violations, \n                                         key=lambda x: x['size'].convert_to_bytes(), \n                                         reverse=True)\n                for violation in sorted_violations[:5]:\n                    report += f\"    {violation['size'].auto_scale():&gt;8} ({violation['age_days']} days) - {violation['path']}\\n\"\n\n                if len(policy_violations) &gt; 5:\n                    report += f\"    ... and {len(policy_violations) - 5} more files\\n\"\n                report += \"\\n\"\n\n        # Oversized directories\n        if violations['oversized_directories']:\n            report += f\"\ud83d\udcc1 Oversized Directories:\\n\"\n            for violation in violations['oversized_directories']:\n                report += f\"  {violation['path']}\\n\"\n                report += f\"    Size: {violation['size'].auto_scale()} (threshold: {violation['threshold'].auto_scale()})\\n\"\n                report += f\"    Overage: {violation['overage'].auto_scale()}\\n\"\n                report += f\"    Policy: {violation['policy']}\\n\"\n            report += \"\\n\"\n\n        # Compression candidates\n        if violations['compression_candidates']:\n            total_compressible = sum(v['size'] for v in violations['compression_candidates'])\n            estimated_savings = sum(v['size'] - v['estimated_compressed_size'] \n                                  for v in violations['compression_candidates'])\n\n            report += f\"\ud83d\udddc\ufe0f  Compression Candidates:\\n\"\n            report += f\"  Total Size: {total_compressible.auto_scale()}\\n\"\n            report += f\"  Estimated Savings: {estimated_savings.auto_scale()}\\n\"\n\n            # Group by policy\n            by_policy = {}\n            for violation in violations['compression_candidates']:\n                policy = violation['policy']\n                if policy not in by_policy:\n                    by_policy[policy] = []\n                by_policy[policy].append(violation)\n\n            for policy_name, policy_violations in by_policy.items():\n                policy_size = sum(v['size'] for v in policy_violations)\n                report += f\"  {policy_name} ({len(policy_violations)} files, {policy_size.auto_scale()})\\n\"\n\n        # Recommendations\n        report += \"\\n\ud83d\udca1 Recommendations:\\n\"\n\n        if violations['expired_files']:\n            expired_size = sum(v['size'] for v in violations['expired_files'])\n            report += f\"  1. Archive or delete {len(violations['expired_files'])} expired files to free {expired_size.auto_scale()}\\n\"\n\n        if violations['compression_candidates']:\n            comp_savings = sum(v['size'] - v['estimated_compressed_size'] \n                             for v in violations['compression_candidates'])\n            report += f\"  2. Compress {len(violations['compression_candidates'])} files to save ~{comp_savings.auto_scale()}\\n\"\n\n        if violations['oversized_directories']:\n            report += f\"  3. Review {len(violations['oversized_directories'])} oversized directories for cleanup opportunities\\n\"\n\n        if violations['total_violations'] == 0:\n            report += \"  \u2705 All policies are currently in compliance!\\n\"\n\n        return report\n\n    def enforce_policies(self, dry_run: bool = True) -&gt; Dict[str, any]:\n        \"\"\"Enforce retention policies by archiving/deleting files.\"\"\"\n        violations = self.scan_policy_violations()\n\n        results = {\n            'files_processed': 0,\n            'files_deleted': 0,\n            'files_archived': 0,\n            'files_compressed': 0,\n            'space_freed': Storage(0, StorageUnit.BYTES),\n            'space_saved': Storage(0, StorageUnit.BYTES),\n            'errors': [],\n            'dry_run': dry_run\n        }\n\n        # Process expired files\n        for violation in violations['expired_files']:\n            results['files_processed'] += 1\n            file_path = Path(violation['path'])\n\n            if not dry_run:\n                try:\n                    if violation['action'] == 'archive':\n                        # Archive file\n                        policy = self.policies[violation['policy']]\n                        archive_dir = Path(policy['archive_location'])\n                        archive_dir.mkdir(parents=True, exist_ok=True)\n\n                        archive_path = archive_dir / file_path.name\n                        file_path.rename(archive_path)\n\n                        results['files_archived'] += 1\n                        print(f\"Archived: {file_path} -&gt; {archive_path}\")\n                    else:\n                        # Delete file\n                        file_path.unlink()\n                        results['files_deleted'] += 1\n                        results['space_freed'] += violation['size']\n                        print(f\"Deleted: {file_path}\")\n\n                except Exception as e:\n                    error_msg = f\"Failed to process {file_path}: {e}\"\n                    results['errors'].append(error_msg)\n                    print(error_msg)\n            else:\n                action = \"Archive\" if violation['action'] == 'archive' else \"Delete\"\n                print(f\"Would {action.lower()}: {file_path} ({violation['size'].auto_scale()})\")\n                if violation['action'] == 'delete':\n                    results['space_freed'] += violation['size']\n\n        return results\n\n# Usage example\nmonitor = DataRetentionMonitor()\n\n# Scan for violations\nprint(\"\ud83d\udd0d Scanning for retention policy violations...\")\nviolations = monitor.scan_policy_violations()\n\n# Generate compliance report\nreport = monitor.generate_compliance_report(violations)\nprint(report)\n\n# Enforce policies (dry run first)\nif violations['total_violations'] &gt; 0:\n    print(\"\\n\ud83d\udd27 Enforcing policies (dry run)...\")\n    enforcement_result = monitor.enforce_policies(dry_run=True)\n\n    print(f\"Would process {enforcement_result['files_processed']} files\")\n    print(f\"Would free {enforcement_result['space_freed'].auto_scale()} of space\")\n\n    # Uncomment to actually enforce policies\n    # enforcement_result = monitor.enforce_policies(dry_run=False)\n</code></pre> <p> [{\"content\": \"Update existing documentation to English\", \"status\": \"completed\", \"priority\": \"high\", \"id\": \"1\"}, {\"content\": \"Complete API reference documentation\", \"status\": \"completed\", \"priority\": \"high\", \"id\": \"2\"}, {\"content\": \"Create user guide sections\", \"status\": \"completed\", \"priority\": \"medium\", \"id\": \"3\"}, {\"content\": \"Add examples and real-world scenarios\", \"status\": \"completed\", \"priority\": \"medium\", \"id\": \"4\"}, {\"content\": \"Update banner URL in documentation\", \"status\": \"completed\", \"priority\": \"low\", \"id\": \"5\"}]"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to Bytesize! This section will help you quickly get up to speed with this powerful storage unit library.</p>"},{"location":"getting-started/#learning-path","title":"\ud83c\udfaf Learning Path","text":"<p>Follow this sequence to master Bytesize core features in 30 minutes:</p> <pre><code>graph LR\n    A[Installation] --&gt; B[Quick Start]\n    B --&gt; C[Basic Concepts]\n    C --&gt; D[User Guide]\n    D --&gt; E[Advanced Features]\n\n    style A fill:#e8f5e8\n    style B fill:#e3f2fd\n    style C fill:#fff3e0\n    style D fill:#f3e5f5\n    style E fill:#fce4ec</code></pre>"},{"location":"getting-started/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<ul> <li>Python 3.9 or higher</li> <li>Basic Python programming knowledge</li> <li>Understanding of storage unit concepts (KB, MB, GB, etc.)</li> </ul>"},{"location":"getting-started/#quick-start-steps","title":"\ud83d\ude80 Quick Start Steps","text":""},{"location":"getting-started/#1-install-bytesize","title":"1. Install Bytesize","text":"<p>Choose your preferred installation method:</p> pipuvpoetry <pre><code>pip install bytesize\n</code></pre> <pre><code>uv add bytesize\n</code></pre> <pre><code>poetry add bytesize\n</code></pre>"},{"location":"getting-started/#2-verify-installation","title":"2. Verify Installation","text":"<pre><code>from bytesize import Storage, StorageUnit\nprint(\"Bytesize installed successfully!\")\n</code></pre>"},{"location":"getting-started/#3-first-example","title":"3. First Example","text":"<pre><code># Create a 1GB storage object\nstorage = Storage(1, StorageUnit.GB)\nprint(f\"Storage size: {storage}\")  # Output: Storage size: 1.0 GB\n\n# Convert to other units\nprint(f\"Convert to MB: {storage.convert_to_mb()}\")  # Output: Convert to MB: 1000.0 MB\n</code></pre>"},{"location":"getting-started/#whats-next","title":"\ud83d\udcd6 What's Next?","text":"<ul> <li> <p> Quick Start</p> <p>5-minute tutorial to quickly learn core features</p> </li> <li> <p> Basic Concepts</p> <p>Understand storage units and Bytesize design philosophy</p> </li> <li> <p> User Guide</p> <p>Deep dive into all features and functionality</p> </li> <li> <p> Examples</p> <p>Real-world scenarios and best practices</p> </li> </ul>"},{"location":"getting-started/#tips","title":"\ud83d\udca1 Tips","text":"<p>Learning Recommendations</p> <ul> <li>Start with Quick Start to quickly experience Bytesize's main features</li> <li>If you're new to storage unit concepts, read Basic Concepts first</li> <li>When facing issues, check the Examples for similar use cases</li> </ul> <p>Version Compatibility</p> <p>Bytesize supports Python 3.9+. We recommend using the latest stable version for optimal performance.</p>"},{"location":"getting-started/#need-help","title":"\ud83e\udd1d Need Help?","text":"<p>If you encounter problems during usage:</p> <ul> <li>Check the Best Practices</li> <li>Browse Examples</li> <li>Submit a GitHub Issue</li> </ul>"},{"location":"getting-started/concepts/","title":"Basic Concepts","text":"<p>Understanding the core concepts behind FileSizeLib will help you use the library more effectively. This guide covers both fundamental concepts and the latest feature enhancements.</p>"},{"location":"getting-started/concepts/#storage-units-overview","title":"\ud83e\udde0 Storage Units Overview","text":"<p>Storage units represent different ways to measure digital information. FileSizeLib supports three main categories:</p> <pre><code>graph TD\n    A[Digital Storage] --&gt; B[Binary Units]\n    A --&gt; C[Decimal Units]\n    A --&gt; D[Bit Units]\n\n    B --&gt; B1[\"Base 1024&lt;br/&gt;Powers of 2\"]\n    B --&gt; B2[\"KiB, MiB, GiB&lt;br/&gt;TiB, PiB, EiB&lt;br/&gt;ZiB, YiB\"]\n\n    C --&gt; C1[\"Base 1000&lt;br/&gt;Powers of 10\"]\n    C --&gt; C2[\"KB, MB, GB&lt;br/&gt;TB, PB, EB&lt;br/&gt;ZB, YB\"]\n\n    D --&gt; D1[\"Base 1000&lt;br/&gt;Network/Speed\"]\n    D --&gt; D2[\"bits, Kilobits&lt;br/&gt;Megabits, Gigabits&lt;br/&gt;Terabits\"]\n\n    style A fill:#e3f2fd\n    style B fill:#f3e5f5\n    style C fill:#e8f5e8\n    style D fill:#fff3e0</code></pre>"},{"location":"getting-started/concepts/#binary-vs-decimal-units","title":"\ud83d\udcca Binary vs Decimal Units","text":"<p>One of the most important concepts to understand is the difference between binary and decimal units:</p>"},{"location":"getting-started/concepts/#binary-units-base-1024","title":"Binary Units (Base 1024)","text":"<p>Binary units use powers of 2 and are denoted with \"i\" (binary):</p> Unit Full Name Value Bytes B Byte 1 1 KiB Kibibyte 1024\u00b9 1,024 MiB Mebibyte 1024\u00b2 1,048,576 GiB Gibibyte 1024\u00b3 1,073,741,824 TiB Tebibyte 1024\u2074 1,099,511,627,776"},{"location":"getting-started/concepts/#decimal-units-base-1000","title":"Decimal Units (Base 1000)","text":"<p>Decimal units use powers of 10 and are more commonly used by manufacturers:</p> Unit Full Name Value Bytes B Byte 1 1 KB Kilobyte 1000\u00b9 1,000 MB Megabyte 1000\u00b2 1,000,000 GB Gigabyte 1000\u00b3 1,000,000,000 TB Terabyte 1000\u2074 1,000,000,000,000"},{"location":"getting-started/concepts/#why-the-difference-matters","title":"Why the Difference Matters","text":"<pre><code>from filesizelib import Storage, StorageUnit, FileSizeLib\n\n# A \"1 GB\" hard drive actually has different capacities:\ndecimal_gb = Storage(1, StorageUnit.GB)  # 1,000,000,000 bytes\nbinary_gib = FileSizeLib(1, StorageUnit.GIB) # 1,073,741,824 bytes (using alias)\n\nprint(f\"1 GB = {decimal_gb.convert_to_bytes():,.0f} bytes\")\nprint(f\"1 GiB = {binary_gib.convert_to_bytes():,.0f} bytes\")\nprint(f\"Difference: {(binary_gib - decimal_gb).convert_to_bytes():,.0f} bytes\")\n\n# Output:\n# 1 GB = 1,000,000,000 bytes\n# 1 GiB = 1,073,741,824 bytes  \n# Difference: 73,741,824 bytes\n</code></pre> <p>Real-World Impact</p> <p>This is why a \"500 GB\" hard drive might show as only ~465 GiB in your operating system!</p>"},{"location":"getting-started/concepts/#the-storage-class-and-filesizelib-alias","title":"\ud83d\udcbe The Storage Class (and FileSizeLib Alias)","text":"<p>The <code>Storage</code> class is the heart of FileSizeLib. It represents a storage value with these key properties. For convenience, you can also use <code>FileSizeLib</code> as an identical alias to <code>Storage</code>.</p>"},{"location":"getting-started/concepts/#core-components","title":"Core Components","text":"<pre><code>from filesizelib import Storage, StorageUnit, FileSizeLib\n\nstorage = Storage(1.5, StorageUnit.GB)\n# Or equivalently:\nstorage_alias = FileSizeLib(1.5, StorageUnit.GB)  # FileSizeLib is identical to Storage\n\n# Core properties (same for both Storage and FileSizeLib)\nprint(f\"Value: {storage.value}\")  # 1.5\nprint(f\"Unit: {storage.unit}\")    # StorageUnit.GB\nprint(f\"Bytes: {storage.convert_to_bytes()}\")  # 1500000000.0\n</code></pre>"},{"location":"getting-started/concepts/#immutability","title":"Immutability","text":"<p>Storage objects are immutable - operations return new objects:</p> <pre><code>original = Storage(1, StorageUnit.GB)\ndoubled = original * 2\n\nprint(f\"Original: {original}\")  # 1.0 GB (unchanged)\nprint(f\"Doubled: {doubled}\")    # 2.0 GB (new object)\n</code></pre>"},{"location":"getting-started/concepts/#type-safety","title":"Type Safety","text":"<p>Bytesize provides complete type annotations for better IDE support:</p> <pre><code>from filesizelib import Storage, StorageUnit, FileSizeLib\nfrom typing import Union\n\ndef calculate_bandwidth(file_size: Storage, time_seconds: float) -&gt; Storage:\n    \"\"\"Calculate bandwidth given file size and time.\"\"\"\n    bytes_per_second = file_size.convert_to_bytes() / time_seconds\n    return FileSizeLib.parse_from_bytes(bytes_per_second)  # Can use either Storage or FileSizeLib}\n</code></pre>"},{"location":"getting-started/concepts/#conversion-philosophy","title":"\ud83d\udd04 Conversion Philosophy","text":"<p>FileSizeLib provides two approaches to unit conversion:</p>"},{"location":"getting-started/concepts/#1-explicit-conversion","title":"1. Explicit Conversion","text":"<pre><code>storage = Storage(1, StorageUnit.GB)\n\n# Traditional method - explicit and clear\nmb_storage = storage.convert_to(StorageUnit.MB)\nprint(f\"Explicit: {mb_storage}\")  # 1000.0 MB\n</code></pre>"},{"location":"getting-started/concepts/#2-convenient-methods","title":"2. Convenient Methods","text":"<pre><code># Convenient methods - shorter and more readable\nmb_storage = storage.convert_to_mb()\nprint(f\"Convenient: {mb_storage}\")  # 1000.0 MB\n\n# Both produce identical results\nassert storage.convert_to(StorageUnit.MB) == storage.convert_to_mb()\n</code></pre>"},{"location":"getting-started/concepts/#auto-scaling","title":"Auto-Scaling","text":"<p>FileSizeLib can automatically choose the best unit for display:</p> <pre><code>large_file = Storage(1536000000, StorageUnit.BYTES)\n\n# Auto-scale chooses the most readable unit\nprint(f\"Auto-scaled: {large_file.auto_scale()}\")  # 1.43 GIB\n\n# You can prefer binary or decimal\nbinary = large_file.auto_scale(prefer_binary=True)   # 1.43 GIB\ndecimal = large_file.auto_scale(prefer_binary=False) # 1.536 GB\n</code></pre>"},{"location":"getting-started/concepts/#smart-arithmetic-operations","title":"\ud83e\uddee Smart Arithmetic Operations","text":"<p>FileSizeLib supports natural arithmetic operations with intelligent unit handling. When both operands have the same unit, the result preserves that unit for better readability:</p>"},{"location":"getting-started/concepts/#basic-operations","title":"Basic Operations","text":"<pre><code>graph LR\n    A[Storage A] --&gt; C[Result]\n    B[Storage B] --&gt; C\n    O[Operator] --&gt; C\n\n    C --&gt; D[Automatic Unit&lt;br/&gt;Conversion]\n    D --&gt; E[Result in&lt;br/&gt;Appropriate Unit]\n\n    style A fill:#e8f5e8\n    style B fill:#e8f5e8  \n    style C fill:#fff3e0\n    style D fill:#f3e5f5\n    style E fill:#e3f2fd</code></pre>"},{"location":"getting-started/concepts/#smart-unit-handling-rules","title":"Smart Unit Handling Rules","text":"<ol> <li>Same-Unit Addition/Subtraction: When both operands have the same unit, result preserves that unit</li> <li>Mixed-Unit Addition/Subtraction: Different units automatically convert to bytes  </li> <li>Multiplication: Result keeps the storage unit (factor is dimensionless)</li> <li>Division: Can return Storage (when dividing by a number) or float (when dividing by Storage)</li> </ol> <pre><code>from filesizelib import Storage, StorageUnit, FileSizeLib\n\n# Same-unit operations preserve unit\nsame_unit_1 = Storage(1, StorageUnit.GB)\nsame_unit_2 = Storage(2, StorageUnit.GB)  \ntotal_same = same_unit_1 + same_unit_2\nprint(f\"Same units: {total_same}\")  # 3 GB (unit preserved!)\n\n# Mixed-unit operations convert to bytes\nfile1 = Storage(1.5, StorageUnit.GB)\nfile2 = Storage(512, StorageUnit.MB)\ntotal_mixed = file1 + file2\nprint(f\"Mixed units: {total_mixed}\")  # 2012000000.0 BYTES\n\n# Use auto_scale for readability\nprint(f\"Readable: {total_mixed.auto_scale()}\")  # 1.87 GIB\n\n# Division - different result types\nper_chunk = file1 / 3      # Storage object\nratio = file1 / file2      # float ratio\n\nprint(f\"Per chunk: {per_chunk}\")  # 0.5 GB\nprint(f\"Ratio: {ratio:.2f}\")       # 2.93\n</code></pre>"},{"location":"getting-started/concepts/#file-system-integration","title":"\ud83d\udcc1 File System Integration","text":"<p>FileSizeLib integrates seamlessly with Python's file system operations:</p>"},{"location":"getting-started/concepts/#path-handling","title":"Path Handling","text":"<pre><code>from pathlib import Path\nfrom filesizelib import Storage, FileSizeLib\n\n# Works with strings and Path objects (use Storage or FileSizeLib)\nfile_size = Storage.get_size_from_path(\"README.md\")\ndir_size = FileSizeLib.get_size_from_path(Path(\"./docs\"))  # Same functionality\n\nprint(f\"File: {file_size.auto_scale()}\")\nprint(f\"Directory: {dir_size.auto_scale()}\")\n</code></pre>"},{"location":"getting-started/concepts/#platform-optimizations","title":"Platform Optimizations","text":"<p>FileSizeLib provides platform-specific optimizations:</p> <pre><code>graph TD\n    A[Storage.get_platform_storage] --&gt; B{Platform Detection}\n\n    B --&gt;|Windows| C[WindowsStorage]\n    B --&gt;|Linux| D[LinuxStorage] \n    B --&gt;|macOS| E[MacStorage]\n\n    C --&gt; F[Windows API&lt;br/&gt;Optimizations]\n    D --&gt; G[Linux-specific&lt;br/&gt;System Calls]\n    E --&gt; H[macOS File&lt;br/&gt;System APIs]\n\n    style A fill:#e3f2fd\n    style B fill:#fff3e0\n    style C fill:#ffebee\n    style D fill:#e8f5e8\n    style E fill:#f3e5f5</code></pre>"},{"location":"getting-started/concepts/#string-parsing-flexibility","title":"\ud83d\udd24 String Parsing Flexibility","text":"<p>FileSizeLib's string parser is designed to handle real-world input:</p>"},{"location":"getting-started/concepts/#supported-formats","title":"Supported Formats","text":"<pre><code># All of these work (Storage and FileSizeLib identical):\nsizes = [\n    Storage.parse(\"1.5 GB\"),      # Standard format\n    FileSizeLib.parse(\"1.5GB\"),      # No space (using alias)\n    Storage.parse(\"1,5 GB\"),      # European decimal\n    FileSizeLib.parse(\"1.5 gb\"),     # Lowercase (using alias)\n    Storage.parse(\"1.5 gigabytes\"), # Full name\n    FileSizeLib.parse(\"1.5 g\"),      # Single letter (using alias)\n    Storage.parse(\"1536\"),        # Just number (bytes)\n]\n\n### Parser Rules\n\n1. **Case insensitive**: `GB`, `gb`, `Gb` all work\n2. **Flexible spacing**: Space optional between number and unit\n3. **Multiple separators**: Both `.` and `,` accepted as decimal separators\n4. **Unit aliases**: Full names, abbreviations, and single letters\n5. **Default unit**: Numbers without units default to bytes\n\n## \ud83c\udfaf Design Philosophy\n\nFileSizeLib follows these core principles:\n\n### Pythonic\n\n```python\n# Natural, readable operations\ntotal_size = file1 + file2 + file3\naverage_size = total_size / 3\nis_large = file_size &gt; Storage.parse(\"1 GB\")\n</code></pre>"},{"location":"getting-started/concepts/#explicit-is-better-than-implicit","title":"Explicit is Better than Implicit","text":"<pre><code># Clear about what units you're working with\nbandwidth = Storage(100, StorageUnit.MEGABITS)  # Network speed\nfile_size = Storage(100, StorageUnit.MB)        # File size\n\n# Explicit conversions\nprint(f\"Bandwidth: {bandwidth.convert_to_megabits()}\")\nprint(f\"File size: {file_size.convert_to_mb()}\")\n</code></pre>"},{"location":"getting-started/concepts/#zero-dependencies","title":"Zero Dependencies","text":"<p>FileSizeLib uses only Python's standard library, making it: - Lightweight and fast to install - More secure (fewer attack vectors) - Highly compatible across Python versions - Easy to audit and maintain</p>"},{"location":"getting-started/concepts/#performance-considerations","title":"\ud83d\ude80 Performance Considerations","text":""},{"location":"getting-started/concepts/#efficient-operations","title":"Efficient Operations","text":"<pre><code># These operations are optimized:\nlarge_list = [FileSizeLib.parse(f\"{i} MB\") for i in range(1000)]  # Using alias\ntotal = sum(large_list, Storage(0, StorageUnit.BYTES))  # Efficient sum\n\n# Same-unit operations are extra efficient (no conversion needed)\nsame_unit_list = [Storage(i, StorageUnit.GB) for i in range(100)]\nsame_unit_total = sum(same_unit_list, Storage(0, StorageUnit.GB))  # Preserves GB\n\n# Chaining is also optimized:\nresult = (Storage.parse(\"1 TB\")\n          .convert_to_gib()\n          .convert_to_mb()\n          .auto_scale())\n</code></pre>"},{"location":"getting-started/concepts/#platform-optimizations_1","title":"Platform Optimizations","text":"<p>Each platform-specific storage class provides optimized file operations:</p> <ul> <li>Windows: Uses Windows API for faster directory traversal</li> <li>Linux: Leverages Linux-specific system calls</li> <li>macOS: Uses native macOS file system APIs</li> </ul>"},{"location":"getting-started/concepts/#decimal-precision-control","title":"\ud83c\udfa8 Decimal Precision Control","text":"<p>FileSizeLib eliminates scientific notation and provides configurable decimal precision:</p> <pre><code>from filesizelib import Storage, StorageUnit\n\n# Default precision (20 decimal places) - no scientific notation\nsmall_value = Storage(9.872019291e-05, StorageUnit.GIB)\nprint(f\"Default: {small_value}\")  # 0.00009872019291 GIB (no scientific notation!)\n\n# Configure precision\nStorage.set_decimal_precision(5)\nprint(f\"5 decimals: {small_value}\")  # 0.0001 GIB\n\n# Get current precision\nprint(f\"Current: {Storage.get_decimal_precision()}\")  # 5\n\n# Reset to default\nStorage.set_decimal_precision(20)\n</code></pre>"},{"location":"getting-started/concepts/#new-features-guide","title":"\ud83c\udd95 New Features Guide","text":"<p>FileSizeLib has been enhanced with powerful new features that make it even more intuitive and flexible.</p>"},{"location":"getting-started/concepts/#multiple-aliases","title":"Multiple Aliases","text":"<p>Choose the class name that feels most natural to you - they're all functionally identical:</p> <pre><code>from filesizelib import Storage, FileSizeLib, FileSize\n\n# All of these are exactly the same\nstorage = Storage(\"1.5 GB\")\nfilesizelib = FileSizeLib(\"1.5 GB\")  \nfilesize = FileSize(\"1.5 GB\")          # \ud83c\udd95 NEW\n\nprint(storage == filesizelib == filesize)  # True\n</code></pre>"},{"location":"getting-started/concepts/#direct-string-initialization","title":"Direct String Initialization","text":"<p>Major improvement: No more <code>.parse()</code> calls needed!</p> <pre><code># \ud83c\udd95 NEW: Direct string initialization (recommended)\nsize1 = Storage(\"1.5 GB\")              # Clean and simple\nsize2 = FileSize(\"2048\")                # No unit = bytes\nsize3 = Storage(\"1,5 GB\")               # European decimal separator\n\n# \ud83d\udd04 Traditional approach still works\nsize4 = Storage.parse(\"1.5 GB\")        # Old way\nsize5 = Storage(1.5, StorageUnit.GB)   # Numeric way\n\n# All approaches are equivalent\nassert Storage(\"1 GB\") == Storage.parse(\"1 GB\") == Storage(1, StorageUnit.GB)\n</code></pre>"},{"location":"getting-started/concepts/#property-based-conversions","title":"Property-Based Conversions","text":"<p>Game changer: Access any unit as a simple property!</p> <pre><code>file_size = Storage(\"1.5 GB\")\n\n# \ud83c\udd95 Property access - incredibly convenient\nprint(file_size.MB)          # 1500.0 MB\nprint(file_size.GIB)         # 1.396 GIB\nprint(file_size.BITS)        # 12000000000.0 BITS\nprint(file_size.BYTES)       # 1500000000 BYTES\n\n# \ud83c\udd95 Property chaining works too!\nresult = Storage(\"1 TiB\").GIB.MIB\nprint(result)                 # 1048576.0 MIB\n\n# \ud83d\udd04 Traditional methods still available\nprint(file_size.convert_to_mb())  # Same as file_size.MB\n</code></pre>"},{"location":"getting-started/concepts/#smart-type-conversion","title":"Smart Type Conversion","text":"<p>Critical feature: Built-in <code>int()</code> and <code>float()</code> support for byte operations.</p> <pre><code>storage = Storage(\"1.5 GB\")\n\n# \ud83c\udd95 Magic methods return bytes\nbytes_as_int = int(storage)     # 1500000000 (integer bytes)\nbytes_as_float = float(storage) # 1500000000.0 (float bytes)\n\n# Original value and unit unchanged\nprint(storage.value)            # 1.5 (original value)\nprint(storage.unit)             # StorageUnit.GB (original unit)\n</code></pre>"},{"location":"getting-started/concepts/#critical-concept-value-vs-int-vs-float","title":"\ud83d\udd0d Critical Concept: .value vs int() vs float()","text":"<p>This is the most important concept to understand - these three approaches return completely different values:</p> <pre><code>file_size = Storage(\"1.5 GB\")\n\n# 1. .value - Returns the ORIGINAL numeric value in the ORIGINAL unit\noriginal_value = file_size.value        # 1.5 (the GB value)\noriginal_unit = file_size.unit          # StorageUnit.GB\nprint(f\"Original: {original_value} {original_unit.name}\")  # \"1.5 GB\"\n\n# 2. int() - Returns TOTAL BYTES as integer (for exact operations)\ntotal_bytes_int = int(file_size)        # 1500000000 (bytes as int)\nprint(f\"Bytes (int): {total_bytes_int}\")\n\n# 3. float() - Returns TOTAL BYTES as float (for calculations)\ntotal_bytes_float = float(file_size)    # 1500000000.0 (bytes as float)\nprint(f\"Bytes (float): {total_bytes_float}\")\n\n# Real-world usage examples:\n\n# Use .value for display purposes\ndisplay_text = f\"{file_size.value} {file_size.unit.name}\"  # \"1.5 GB\"\n\n# Use int() for exact byte operations, file I/O, comparisons\nif int(file_size) &gt; 1000000000:  # Compare exact bytes\n    print(\"Large file detected\")\n\n# Use float() for mathematical calculations\ncompression_ratio = float(original_file) / float(compressed_file)\naverage_size = float(total_size) / file_count\n\n# Properties return Storage objects (not raw numbers!)\nmb_storage = file_size.MB               # Returns Storage(1500.0, MB)\nmb_bytes = int(file_size.MB)            # Still 1500000000 bytes!\nmb_display = file_size.MB.value         # 1500.0 (MB value only)\n</code></pre>"},{"location":"getting-started/concepts/#common-patterns-with-new-features","title":"Common Patterns with New Features","text":"<pre><code># Pattern 1: Quick byte operations\nfile_sizes = [Storage(\"1.5 GB\"), FileSize(\"2.5 GB\"), Storage(\"500 MB\")]\ntotal_bytes = sum(int(size) for size in file_sizes)  # Exact byte sum\nprint(f\"Total: {total_bytes:,} bytes\")\n\n# Pattern 2: Unit-specific calculations  \ngb_sizes = [Storage(\"1.5 GB\"), Storage(\"2.0 GB\"), Storage(\"0.5 GB\")]\ntotal_gb = sum(size.value for size in gb_sizes)      # Sum GB values only\nprint(f\"Total: {total_gb} GB\")\n\n# Pattern 3: Mixed unit operations with properties\nlarge_file = Storage(\"1.5 TB\")\nprint(f\"Size breakdown:\")\nprint(f\"  TB: {large_file.TB}\")\nprint(f\"  TiB: {large_file.TIB}\")  \nprint(f\"  GB: {large_file.GB}\")\nprint(f\"  Bytes: {int(large_file):,}\")\n\n# Pattern 4: Chaining with type conversion\nresult = int(FileSize(\"1 GiB\").MB)      # 1073741824 bytes\nratio = float(Storage(\"2 GB\")) / float(Storage(\"1 GB\"))  # 2.0\n</code></pre>"},{"location":"getting-started/concepts/#migration-guide","title":"Migration Guide","text":"<p>If you're upgrading from an older version:</p> <pre><code># \u2705 All existing code continues to work unchanged\nold_style = Storage(1.5, StorageUnit.GB)\nparsed = Storage.parse(\"1.5 GB\")\nconverted = old_style.convert_to_mb()\n\n# \ud83c\udd95 But you can now use simpler approaches\nnew_style = Storage(\"1.5 GB\")           # Direct initialization\nquick_convert = new_style.MB            # Property conversion\nexact_bytes = int(new_style)            # Magic method\n</code></pre>"},{"location":"getting-started/concepts/#next-steps","title":"\ud83d\udcda Next Steps","text":"<p>Now that you understand the core concepts:</p> <ul> <li> <p> User Guide</p> <p>Explore all features in detail</p> </li> <li> <p> Examples</p> <p>See practical applications and patterns</p> </li> <li> <p> API Reference</p> <p>Complete method and class documentation</p> </li> <li> <p> Best Practices</p> <p>Performance tips and recommended patterns</p> </li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Get Bytesize up and running in your Python environment quickly and easily.</p>"},{"location":"getting-started/installation/#requirements","title":"\ud83d\udccb Requirements","text":"<p>Before installing Bytesize, ensure you have:</p> <ul> <li>Python 3.9 or higher</li> <li>pip (usually comes with Python)</li> </ul> <p>You can check your Python version with:</p> <pre><code>python --version\n# or\npython3 --version\n</code></pre>"},{"location":"getting-started/installation/#installation-methods","title":"\ud83d\ude80 Installation Methods","text":"pip (Recommended)uv (Fast)poetrypipenvconda <p>Install from PyPI using pip:</p> <pre><code>pip install bytesize\n</code></pre> <p>For Python 3 specifically:</p> <pre><code>pip3 install bytesize\n</code></pre> <p>If you're using uv for faster Python package management:</p> <pre><code>uv add bytesize\n</code></pre> <p>For projects using Poetry:</p> <pre><code>poetry add bytesize\n</code></pre> <p>For projects using Pipenv:</p> <pre><code>pipenv install bytesize\n</code></pre> <p>If using Conda (when available):</p> <pre><code>conda install bytesize\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"\ud83d\udd27 Development Installation","text":"<p>If you want to contribute to Bytesize or use the latest development version:</p>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<pre><code># Clone the repository\ngit clone https://github.com/your-username/bytesize.git\ncd bytesize\n\n# Install in development mode\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#with-development-dependencies","title":"With Development Dependencies","text":"<pre><code># Install with development dependencies\npip install -e \".[dev]\"\n\n# Or with uv\nuv sync --dev\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"\u2705 Verify Installation","text":"<p>After installation, verify that Bytesize is working correctly:</p> <pre><code># Test basic import\nfrom bytesize import Storage, StorageUnit\n\n# Create a simple storage object\nstorage = Storage(1, StorageUnit.GB)\nprint(f\"\u2705 Bytesize installed successfully! Test storage: {storage}\")\n\n# Test conversion\nmb_value = storage.convert_to_mb()\nprint(f\"\u2705 Conversion working: {mb_value}\")\n</code></pre> <p>Expected output: <pre><code>\u2705 Bytesize installed successfully! Test storage: 1.0 GB\n\u2705 Conversion working: 1000.0 MB\n</code></pre></p>"},{"location":"getting-started/installation/#virtual-environment-recommended","title":"\ud83d\udc0d Virtual Environment (Recommended)","text":"<p>We recommend installing Bytesize in a virtual environment to avoid conflicts:</p> venvconda <pre><code># Create virtual environment\npython -m venv myproject\n\n# Activate (Linux/macOS)\nsource myproject/bin/activate\n\n# Activate (Windows)\nmyproject\\Scripts\\activate\n\n# Install Bytesize\npip install bytesize\n</code></pre> <pre><code># Create conda environment\nconda create -n myproject python=3.11\n\n# Activate environment\nconda activate myproject\n\n# Install Bytesize\npip install bytesize\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"\ud83d\udea8 Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":"<p>Permission Issues</p> <p>If you get permission errors on Linux/macOS, try: <pre><code>pip install --user bytesize\n</code></pre></p> <p>Python Version</p> <p>If you get a \"Python version not supported\" error: <pre><code># Check your Python version\npython --version\n\n# Upgrade Python if needed (using pyenv example)\npyenv install 3.11.0\npyenv global 3.11.0\n</code></pre></p> <p>Package Not Found</p> <p>If pip can't find the package: <pre><code># Update pip first\npip install --upgrade pip\n\n# Try installing again\npip install bytesize\n</code></pre></p>"},{"location":"getting-started/installation/#environment-issues","title":"Environment Issues","text":"<p>If you're having environment-related issues:</p> <ol> <li> <p>Check Python path:    <pre><code>which python\nwhich pip\n</code></pre></p> </li> <li> <p>Verify virtual environment:    <pre><code>pip list | grep bytesize\n</code></pre></p> </li> <li> <p>Clear pip cache:    <pre><code>pip cache purge\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#upgrading","title":"\ud83d\udd04 Upgrading","text":"<p>To upgrade to the latest version:</p> <pre><code># Upgrade with pip\npip install --upgrade bytesize\n\n# Check version\npython -c \"import bytesize; print(bytesize.__version__)\"\n</code></pre>"},{"location":"getting-started/installation/#uninstallation","title":"\ud83d\uddd1\ufe0f Uninstallation","text":"<p>To remove Bytesize:</p> <pre><code>pip uninstall bytesize\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"\ud83d\udce6 Dependencies","text":"<p>Bytesize has zero external dependencies - it only uses Python's standard library:</p> <ul> <li><code>pathlib</code> - For cross-platform path operations</li> <li><code>platform</code> - For platform detection</li> <li><code>enum</code> - For storage unit definitions</li> <li><code>typing</code> - For type annotations</li> </ul> <p>This means: - \u2705 Faster installation - \u2705 Smaller footprint - \u2705 Fewer security concerns - \u2705 Better compatibility</p>"},{"location":"getting-started/installation/#next-steps","title":"\ud83c\udfaf Next Steps","text":"<p>Now that you have Bytesize installed:</p> <ul> <li> <p> Quick Start</p> <p>Jump right into using Bytesize with examples</p> </li> <li> <p> Basic Concepts</p> <p>Learn about storage units and core concepts</p> </li> <li> <p> Examples</p> <p>See real-world usage examples</p> </li> <li> <p> API Reference</p> <p>Explore the complete API documentation</p> </li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This 5-minute tutorial will quickly introduce you to FileSizeLib's core features, including the latest enhancements.</p>"},{"location":"getting-started/quick-start/#goals","title":"\ud83c\udfaf Goals","text":"<p>After completing this tutorial, you'll be able to:</p> <ul> <li> Create Storage objects using multiple approaches</li> <li> Use the new FileSize alias and direct string initialization</li> <li> Access conversions via properties (storage.MB, storage.GiB, etc.)</li> <li> Use int() and float() magic methods for byte operations</li> <li> Understand the differences between .value, int(), and float()</li> <li> Perform basic arithmetic operations</li> <li> Use convenient conversion methods</li> <li> Parse string-formatted storage sizes</li> <li> Get file and directory sizes</li> </ul>"},{"location":"getting-started/quick-start/#1-creating-storage-objects","title":"\ud83d\udcbe 1. Creating Storage Objects","text":"<p>Storage has multiple aliases and initialization methods - choose what feels most natural!</p> <pre><code>from filesizelib import Storage, StorageUnit, FileSizeLib, FileSize\n\n# \ud83c\udd95 NEW: Multiple aliases - all functionally identical\nstorage_obj = Storage(\"1.5 GB\")           # Main class\nfilesizelib_obj = FileSizeLib(\"1.5 GB\")   # Original alias\nfilesize_obj = FileSize(\"1.5 GB\")         # \ud83c\udd95 New alias\n\nprint(storage_obj == filesizelib_obj == filesize_obj)  # True\n\n# Method 1: \ud83c\udd95 NEW - Direct string initialization (recommended!)\nfile_size = Storage(\"1.5 GB\")             # No .parse() needed!\nphoto_size = FileSize(\"2.5 MiB\")          # Works with any alias\ndocument_size = Storage(\"500\")             # No unit = bytes\n\n# Method 2: Traditional numeric values and unit enums\nvideo_size = Storage(4.2, StorageUnit.GB) # Classic approach\nmusic_size = FileSizeLib(128, StorageUnit.MB)\n\n# Method 3: Traditional string parsing (still works!)\nlegacy_size = Storage.parse(\"1 TB\")       # .parse() method\n\nprint(f\"File size: {file_size}\")          # 1.5 GB\nprint(f\"Photo size: {photo_size}\")        # 2.5 MIB\nprint(f\"Document: {document_size}\")       # 500 BYTES\nprint(f\"Video size: {video_size}\")        # 4.2 GB\nprint(f\"Music size: {music_size}\")        # 128.0 MB\n</code></pre>"},{"location":"getting-started/quick-start/#2-arithmetic-operations","title":"\ud83e\uddee 2. Arithmetic Operations","text":"<p>FileSizeLib supports intuitive arithmetic operations with smart unit preservation:</p> <pre><code># Addition: Smart unit preservation for same units\nsame_unit_1 = Storage(1, StorageUnit.GB)\nsame_unit_2 = Storage(2, StorageUnit.GB)\ntotal_same = same_unit_1 + same_unit_2\nprint(f\"Same unit result: {total_same}\")  # 3 GB (preserves unit!)\n\n# Different units still convert to bytes\ntotal_mixed = video_size + music_size\nprint(f\"Mixed units result: {total_mixed}\")  # In bytes\n\n# Subtraction: Calculate remaining space\ndisk_capacity = Storage.parse(\"500 GB\")\nremaining = disk_capacity - total_media\nprint(f\"Remaining space: {remaining.auto_scale()}\")  # 495.672 GB\n\n# Multiplication: Batch calculations\nphotos_total = photo_size * 100  # 100 photos\nprint(f\"100 photos total: {photos_total.auto_scale()}\")  # 250.0 MIB\n\n# Division: Calculate ratios or time\ndownload_speed = Storage.parse(\"10 MB\")  # per second\ndownload_time = video_size / download_speed  # seconds\nprint(f\"Download time: {download_time:.1f} seconds\")  # 420.0 seconds\n</code></pre>"},{"location":"getting-started/quick-start/#3-unit-conversion","title":"\ud83d\udd04 3. Unit Conversion","text":""},{"location":"getting-started/quick-start/#new-property-based-conversions-recommended","title":"\ud83c\udd95 NEW: Property-Based Conversions (Recommended!)","text":"<p>The easiest way to convert units - just access them as properties:</p> <pre><code>large_file = Storage(\"1.5 GB\")  # Using string initialization\n\n# \ud83c\udd95 Binary unit properties - instant access!\nprint(f\"MiB: {large_file.MIB}\")    # 1430.51 MiB\nprint(f\"KiB: {large_file.KIB}\")    # 1465149.61 KiB\nprint(f\"GiB: {large_file.GIB}\")    # 1.396 GiB\n\n# \ud83c\udd95 Decimal unit properties  \nprint(f\"MB: {large_file.MB}\")      # 1500.0 MB\nprint(f\"KB: {large_file.KB}\")      # 1500000.0 KB\nprint(f\"TB: {large_file.TB}\")      # 0.0015 TB\n\n# \ud83c\udd95 Bit unit properties\nprint(f\"Bits: {large_file.BITS}\")             # 12000000000.0 BITS\nprint(f\"Megabits: {large_file.MEGABITS}\")     # 12000.0 MEGABITS\nprint(f\"Gigabits: {large_file.GIGABITS}\")     # 12.0 GIGABITS\n\n# \ud83c\udd95 Property chaining works too!\nresult = Storage(\"1 GiB\").MIB.KIB\nprint(f\"Chained conversion: {result}\")        # 1048576.0 KIB\n</code></pre>"},{"location":"getting-started/quick-start/#traditional-methods-still-available","title":"Traditional Methods (Still Available)","text":"<pre><code># Using convert_to_* methods\nprint(f\"Method call: {large_file.convert_to_mib()}\")  # 1430.51 MiB\n\n# Using convert_to method\ntraditional = large_file.convert_to(StorageUnit.MIB)\nprint(f\"Traditional: {traditional}\")                  # 1430.51 MIB\n\n# All approaches produce identical results\nassert large_file.MIB == large_file.convert_to_mib() == traditional\n</code></pre>"},{"location":"getting-started/quick-start/#understanding-value-vs-int-vs-float","title":"\ud83d\udd0d Understanding .value vs int() vs float()","text":"<p>Critical difference - these return different values:</p> <pre><code>size = Storage(\"1.5 GB\")\n\n# .value - Returns original value in original unit\nprint(f\"size.value = {size.value}\")         # 1.5 (GB value)\nprint(f\"size.unit = {size.unit}\")           # StorageUnit.GB\n\n# int() - Returns total bytes as integer  \nprint(f\"int(size) = {int(size)}\")           # 1500000000 (bytes)\n\n# float() - Returns total bytes as float\nprint(f\"float(size) = {float(size)}\")       # 1500000000.0 (bytes)\n\n# Properties return Storage objects (not raw numbers)\nprint(f\"size.MB = {size.MB}\")               # 1500.0 MB (Storage object)\nprint(f\"int(size.MB) = {int(size.MB)}\")     # 1500000000 (still bytes!)\n</code></pre>"},{"location":"getting-started/quick-start/#4-string-parsing","title":"\ud83d\udcdd 4. String Parsing","text":"<p>\ud83c\udd95 Major improvement: Direct string initialization makes parsing effortless!</p> <pre><code># \ud83c\udd95 NEW: Direct initialization (recommended approach)\nsize1 = Storage(\"1.5 GB\")              # No .parse() needed!\nsize2 = FileSize(\"2.5TB\")              # Works with all aliases\nsize3 = FileSizeLib(\"512 mb\")          # Case insensitive\n\n# \ud83c\udd95 Different decimal separators work directly\nsize4 = Storage(\"1,5 GB\")              # European format (comma)\nsize5 = FileSize(\"2.5 GB\")             # US format (dot)\n\n# \ud83c\udd95 Full unit names in constructors\nsize6 = Storage(\"1 gigabyte\")\nsize7 = FileSize(\"500 megabytes\")  \nsize8 = Storage(\"1 kibibyte\")\n\n# \ud83c\udd95 Short forms work directly\nsize9 = Storage(\"1 g\")                 # Single letter\nsize10 = FileSize(\"500 m\")\n\n# \ud83c\udd95 No unit defaults to bytes\nsize11 = Storage(\"1024\")               # Automatically BYTES\n\nprint(\"All formats parsed correctly using direct initialization!\")\n\n# Traditional .parse() method still works\nlegacy1 = Storage.parse(\"1.5 GB\")     # Old way\nlegacy2 = FileSizeLib.parse(\"2TB\")    # Still supported\n\n# Both approaches are identical\nassert Storage(\"1 GB\") == Storage.parse(\"1 GB\")\n</code></pre>"},{"location":"getting-started/quick-start/#5-file-operations","title":"\ud83d\udcc1 5. File Operations","text":"<p>Get actual file and directory sizes:</p> <pre><code># Get single file size\ntry:\n    file_size = Storage.get_size_from_path(\"README.md\")\n    print(f\"README file size: {file_size.auto_scale()}\")\nexcept FileNotFoundError:\n    print(\"File not found\")\n\n# Get directory total size (recursive calculation)\ntry:\n    dir_size = Storage.get_size_from_path(\"./docs\")\n    print(f\"Documentation directory size: {dir_size.auto_scale()}\")\nexcept FileNotFoundError:\n    print(\"Directory not found\")\n\n# Use platform-specific optimizations\nplatform_storage = Storage.get_platform_storage()\ninfo = platform_storage.get_platform_info()\nprint(f\"Current platform: {info['platform']}\")\nprint(f\"Available optimizations: {info.get('api_optimization', 'None')}\")\n</code></pre>"},{"location":"getting-started/quick-start/#6-smart-scaling","title":"\ud83c\udfaf 6. Smart Scaling","text":"<p>The auto_scale() method automatically selects the most appropriate unit:</p> <pre><code># Large file auto-scaling\nhuge_file = Storage(1500000000, StorageUnit.BYTES)\nprint(f\"Smart scaling: {huge_file.auto_scale()}\")  # 1.4 GIB\n\n# Small files keep original unit\nsmall_file = Storage(500, StorageUnit.BYTES)\nprint(f\"Small file: {small_file.auto_scale()}\")   # 500.0 BYTES\n\n# Choose binary or decimal\nbinary_scale = huge_file.auto_scale(prefer_binary=True)   # 1.4 GIB\ndecimal_scale = huge_file.auto_scale(prefer_binary=False) # 1.5 GB\n</code></pre>"},{"location":"getting-started/quick-start/#7-decimal-precision-control","title":"\ud83c\udfa8 7. Decimal Precision Control","text":"<p>FileSizeLib provides configurable decimal precision without scientific notation:</p> <pre><code># Default precision (20 decimal places)\nsmall_value = Storage(9.872019291e-05, StorageUnit.GIB)\nprint(f\"Default: {small_value}\")  # 0.00009872019291 GIB (no scientific notation!)\n\n# Configure precision\nStorage.set_decimal_precision(5)\nprint(f\"5 decimals: {small_value}\")  # 0.0001 GIB\n\n# Get current precision\nprint(f\"Current precision: {Storage.get_decimal_precision()}\")  # 5\n\n# Reset to default\nStorage.set_decimal_precision(20)\n</code></pre>"},{"location":"getting-started/quick-start/#8-method-chaining","title":"\ud83d\udd17 8. Method Chaining","text":"<p>FileSizeLib supports elegant chaining operations:</p> <pre><code># Complex conversion chain\nresult = (Storage.parse(\"2 TB\")\n          .convert_to_gib()      # Convert to GiB\n          .convert_to_mb()       # Convert to MB\n          .auto_scale())         # Smart scaling\n\nprint(f\"Chain conversion result: {result}\")\n\n# Use in arithmetic operations\ntotal = (Storage.parse(\"1.5 GB\").convert_to_mb() + \n         Storage.parse(\"500 MB\"))\nprint(f\"Total size: {total.auto_scale()}\")\n</code></pre>"},{"location":"getting-started/quick-start/#real-world-example","title":"\ud83d\udca1 Real-World Example","text":"<p>Complete scenario showcasing all the new features together:</p> <pre><code>def analyze_media_library(photos_count, video_count):\n    \"\"\"\ud83c\udd95 Enhanced media library analysis using new features\"\"\"\n\n    # \ud83c\udd95 Direct string initialization - no .parse() needed!\n    avg_photo = FileSize(\"2.5 MiB\")         # Using FileSize alias\n    avg_video = Storage(\"500 MB\")           # Using Storage with strings\n\n    # Same-unit arithmetic preserves units\n    photos_total = avg_photo * photos_count if photos_count &gt; 1 else avg_photo\n    videos_total = avg_video * video_count\n\n    # Mixed units convert to bytes\n    total_needed = photos_total + videos_total\n\n    # \ud83c\udd95 Available storage using direct initialization\n    available = Storage(\"1 TB\")\n    remaining = available - total_needed\n\n    # \ud83c\udd95 Analysis results using new features\n    print(f\"\ud83d\udcf8 {photos_count} photos: {photos_total.auto_scale()}\")\n    print(f\"\ud83c\udfac {video_count} videos: {videos_total.auto_scale()}\")\n    print(f\"\ud83d\udce6 Total needed: {total_needed.auto_scale()}\")\n\n    # \ud83c\udd95 Property-based conversions for detailed breakdown\n    print(f\"\ud83d\udcca Total needed breakdown:\")\n    print(f\"   GB: {total_needed.GB}\")\n    print(f\"   GiB: {total_needed.GIB}\")\n    print(f\"   Bytes: {int(total_needed):,}\")    # \ud83c\udd95 int() for exact bytes\n\n    print(f\"\ud83d\udcbe Available: {available}\")\n    print(f\"\u2705 Remaining: {remaining.auto_scale()}\")\n\n    # \ud83c\udd95 Usage calculation using float() for precision\n    if int(remaining) &gt; 0:                        # \ud83c\udd95 int() for byte check\n        usage_percent = (float(total_needed) / float(available)) * 100\n        print(f\"\ud83d\udcca Usage: {usage_percent:.1f}%\")\n\n        # \ud83c\udd95 Different unit representations using properties\n        print(f\"\ud83d\udcc8 Usage in different units:\")\n        print(f\"   {total_needed.GB.value:.1f} / {available.GB.value:.1f} GB\")\n        print(f\"   {total_needed.GIB.value:.1f} / {available.GIB.value:.1f} GiB\")\n    else:\n        print(\"\u26a0\ufe0f  Insufficient storage space!\")\n\n    # \ud83c\udd95 Return detailed info using all new features\n    return {\n        'total_needed': total_needed,\n        'total_bytes': int(total_needed),         # \ud83c\udd95 Exact byte count\n        'total_gb': total_needed.GB.value,       # \ud83c\udd95 GB value only\n        'available': available,\n        'remaining': remaining,\n        'usage_percent': (float(total_needed) / float(available)) * 100\n    }\n\n# Run enhanced analysis\nresult = analyze_media_library(photos_count=1000, video_count=50)\n\n# \ud83c\udd95 Use the returned data with new features\nprint(f\"\\n\ud83d\udd0d Advanced analysis:\")\nprint(f\"Exact byte count: {result['total_bytes']:,}\")\nprint(f\"GB value only: {result['total_gb']:.2f}\")\nprint(f\"Usage percentage: {result['usage_percent']:.2f}%\")\n</code></pre>"},{"location":"getting-started/quick-start/#congratulations","title":"\ud83c\udf89 Congratulations!","text":"<p>You've mastered FileSizeLib's core features, including all the latest enhancements! Now you can:</p> <ul> <li>\u2705 Create objects using multiple aliases (Storage, FileSizeLib, FileSize)</li> <li>\u2705 \ud83c\udd95 Use direct string initialization - <code>Storage(\"1.5 GB\")</code></li> <li>\u2705 \ud83c\udd95 Access any unit as a property - <code>storage.MB</code>, <code>storage.GiB</code>, etc.</li> <li>\u2705 \ud83c\udd95 Use int() and float() for precise byte operations</li> <li>\u2705 \ud83c\udd95 Understand the critical differences between .value, int(), and float()</li> <li>\u2705 Perform smart arithmetic with unit preservation</li> <li>\u2705 Control decimal precision and eliminate scientific notation</li> <li>\u2705 Use convenient conversion methods (both old and new)</li> <li>\u2705 Parse multiple string formats with flexible approaches</li> <li>\u2705 Handle file and directory sizes</li> <li>\u2705 Use smart scaling and method chaining</li> <li>\u2705 \ud83c\udd95 Chain property conversions for complex operations</li> </ul>"},{"location":"getting-started/quick-start/#next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li> <p> Basic Concepts</p> <p>Deep dive into storage units and design principles</p> </li> <li> <p> User Guide</p> <p>Learn more advanced features and best practices</p> </li> <li> <p> Examples</p> <p>See more real-world application scenarios</p> </li> <li> <p> API Reference</p> <p>Explore complete method and property documentation</p> </li> </ul>"},{"location":"user-guide/","title":"User Guide","text":"<p>Comprehensive guide to using FileSizeLib effectively in your projects.</p>"},{"location":"user-guide/#overview","title":"\ud83c\udfaf Overview","text":"<p>This user guide provides practical information for integrating FileSizeLib into your applications. Whether you're building a file manager, monitoring tool, or any application that deals with storage sizes, this guide will help you make the most of FileSizeLib.</p>"},{"location":"user-guide/#guide-sections","title":"\ud83d\udcda Guide Sections","text":"<ul> <li> <p> Quick Start Guide</p> <p>Get up and running with FileSizeLib in minutes</p> </li> <li> <p> Best Practices</p> <p>Learn recommended patterns and avoid common pitfalls</p> </li> </ul>"},{"location":"user-guide/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"user-guide/#installation","title":"Installation","text":"<pre><code>pip install filesizelib\n</code></pre>"},{"location":"user-guide/#basic-usage","title":"Basic Usage","text":"<pre><code>from filesizelib import Storage, StorageUnit, FileSizeLib\n\n# Create storage objects (Storage and FileSizeLib are identical)\nfile_size = Storage(1.5, StorageUnit.GB)\nmemory = FileSizeLib(8, StorageUnit.GIB)  # Using alias\n\n# Parse from strings\ndownload = Storage.parse(\"150 MB\")\nupload = FileSizeLib.parse(\"2.3 TB\")  # Using alias\n\n# Smart arithmetic - same units preserve unit\nsame_unit_total = file_size + Storage(0.5, StorageUnit.GB)\nprint(f\"Same unit: {same_unit_total}\")    # 2.0 GB (unit preserved!)\n\n# Mixed units convert to bytes\nmixed_total = file_size + download  \nprint(f\"Mixed: {mixed_total.auto_scale()}\")  # 1.65 GB\n\nratio = upload / download\nprint(f\"Ratio: {ratio:.1f}\")             # Ratio: 15.7\n</code></pre>"},{"location":"user-guide/#key-concepts","title":"\ud83c\udfaf Key Concepts","text":""},{"location":"user-guide/#storage-units-filesizelib-alias","title":"Storage Units &amp; FileSizeLib Alias","text":"<p>FileSizeLib provides both the main <code>Storage</code> class and an identical <code>FileSizeLib</code> alias for convenience:</p> <p>FileSizeLib supports three types of storage units:</p> Binary Units (Base 1024)Decimal Units (Base 1000)Bit Units <pre><code># Binary units for computer memory and file systems\nram = Storage(16, StorageUnit.GIB)      # 16 GiB\ncache = Storage(512, StorageUnit.MIB)   # 512 MiB\nbuffer = Storage(4, StorageUnit.KIB)    # 4 KiB\n</code></pre> <pre><code># Decimal units for storage devices and marketing\nssd = Storage(500, StorageUnit.GB)      # 500 GB\nbackup = Storage(2, StorageUnit.TB)     # 2 TB\nfile = Storage(150, StorageUnit.MB)     # 150 MB\n</code></pre> <pre><code># Bit units for network and bandwidth\nconnection = Storage(100, StorageUnit.MEGABITS)  # 100 Mbps\nfiber = Storage(1, StorageUnit.GIGABITS)         # 1 Gbps\n</code></pre>"},{"location":"user-guide/#conversions","title":"Conversions","text":"<pre><code># Automatic scaling\nlarge_file = Storage(1536000000, StorageUnit.BYTES)\nprint(large_file.auto_scale())  # 1.43 GIB\n\n# Specific conversions\ngb_size = large_file.convert_to_gb()\nprint(gb_size)  # 1.536 GB\n\n# Convenient methods\nmib_size = large_file.convert_to_mib()\nprint(mib_size)  # 1464.84 MIB\n</code></pre>"},{"location":"user-guide/#file-operations","title":"File Operations","text":"<pre><code>from pathlib import Path\n\n# Get file sizes\nreadme_size = Storage.get_size_from_path(\"README.md\")\ndocs_size = FileSizeLib.get_size_from_path(\"./docs\")  # Using alias\n\nprint(f\"README: {readme_size.auto_scale()}\")\nprint(f\"Docs: {docs_size.auto_scale()}\")\n\n# Works with Path objects\nlog_path = Path(\"/var/log\")\nlog_size = Storage.get_size_from_path(log_path)\n</code></pre>"},{"location":"user-guide/#decimal-precision-control","title":"Decimal Precision Control","text":"<p>FileSizeLib eliminates scientific notation and provides configurable decimal precision:</p> <pre><code># Default precision avoids scientific notation\nsmall_value = Storage(9.872019291e-05, StorageUnit.GIB)\nprint(f\"No scientific notation: {small_value}\")  # 0.00009872019291 GIB\n\n# Configure precision globally\nStorage.set_decimal_precision(3)\nprint(f\"3 decimals: {small_value}\")  # 0.0001 GIB\n\n# Check current precision\nprecision = FileSizeLib.get_decimal_precision()\nprint(f\"Current precision: {precision}\")  # 3\n\n# Reset to default\nStorage.set_decimal_precision(20)\n</code></pre>"},{"location":"user-guide/#common-patterns","title":"\ud83c\udfa8 Common Patterns","text":""},{"location":"user-guide/#file-size-analysis","title":"File Size Analysis","text":"<pre><code>def analyze_project_files():\n    \"\"\"Analyze file sizes in a project.\"\"\"\n    total_size = Storage(0, StorageUnit.BYTES)\n    file_sizes = {}\n\n    for file_path in Path(\".\").rglob(\"*\"):\n        if file_path.is_file():\n            size = Storage.get_size_from_path(file_path)\n            total_size += size\n            file_sizes[str(file_path)] = size\n\n    # Find largest files\n    largest = sorted(file_sizes.items(), key=lambda x: x[1].convert_to_bytes(), reverse=True)[:5]\n\n    print(f\"Total project size: {total_size.auto_scale()}\")\n    print(\"Largest files:\")\n    for path, size in largest:\n        print(f\"  {path}: {size.auto_scale()}\")\n\nanalyze_project_files()\n</code></pre>"},{"location":"user-guide/#bandwidth-calculations","title":"Bandwidth Calculations","text":"<pre><code>def calculate_transfer_time(file_size_str: str, bandwidth_str: str) -&gt; str:\n    \"\"\"Calculate how long a file transfer will take.\"\"\"\n    file_size = Storage.parse(file_size_str)\n    bandwidth = Storage.parse(bandwidth_str)\n\n    # Convert to consistent units (bits)\n    file_bits = file_size.convert_to_bits()\n    bandwidth_bits = bandwidth.convert_to_bits()\n\n    # Calculate time in seconds\n    seconds = file_bits.value / bandwidth_bits.value\n\n    # Format time appropriately\n    if seconds &lt; 60:\n        return f\"{seconds:.1f} seconds\"\n    elif seconds &lt; 3600:\n        return f\"{seconds/60:.1f} minutes\"\n    else:\n        return f\"{seconds/3600:.1f} hours\"\n\n# Usage\nprint(calculate_transfer_time(\"4.7 GB\", \"50 Megabits\"))  # DVD over broadband\nprint(calculate_transfer_time(\"1 TB\", \"1 Gigabit\"))      # Large backup over fiber\n</code></pre>"},{"location":"user-guide/#storage-planning","title":"Storage Planning","text":"<pre><code>class StoragePlanner:\n    \"\"\"Plan storage requirements for different content types.\"\"\"\n\n    def __init__(self, total_capacity: str):\n        self.capacity = Storage.parse(total_capacity)\n        self.allocations = {}\n        self.used = Storage(0, StorageUnit.BYTES)\n\n    def add_content_type(self, name: str, avg_size: str, quantity: int):\n        \"\"\"Add a content type allocation.\"\"\"\n        unit_size = Storage.parse(avg_size)\n        total_size = unit_size * quantity\n\n        self.allocations[name] = {\n            'unit_size': unit_size,\n            'quantity': quantity,\n            'total_size': total_size\n        }\n        self.used += total_size\n\n    def get_summary(self) -&gt; str:\n        \"\"\"Get storage planning summary.\"\"\"\n        remaining = self.capacity - self.used\n        usage_percent = (self.used / self.capacity) * 100\n\n        summary = f\"Storage Planning Summary\\n\"\n        summary += f\"Total Capacity: {self.capacity.auto_scale()}\\n\"\n        summary += f\"Used: {self.used.auto_scale()} ({usage_percent:.1f}%)\\n\"\n        summary += f\"Remaining: {remaining.auto_scale()}\\n\\n\"\n\n        summary += \"Allocations:\\n\"\n        for name, alloc in self.allocations.items():\n            summary += f\"  {name}: {alloc['quantity']} \u00d7 {alloc['unit_size'].auto_scale()} = {alloc['total_size'].auto_scale()}\\n\"\n\n        return summary\n\n# Usage\nplanner = StoragePlanner(\"1 TB\")\nplanner.add_content_type(\"Photos\", \"3 MB\", 2000)\nplanner.add_content_type(\"Videos\", \"800 MB\", 20)\nplanner.add_content_type(\"Music\", \"4.5 MB\", 500)\nplanner.add_content_type(\"Documents\", \"150 KB\", 1000)\n\nprint(planner.get_summary())\n</code></pre>"},{"location":"user-guide/#integration-examples","title":"\ud83d\udd17 Integration Examples","text":""},{"location":"user-guide/#with-web-frameworks","title":"With Web Frameworks","text":"<pre><code># Flask example\nfrom flask import Flask, jsonify\nfrom filesizelib import Storage, FileSizeLib\n\napp = Flask(__name__)\n\n@app.route('/api/disk-usage')\ndef disk_usage():\n    \"\"\"API endpoint for disk usage information.\"\"\"\n    try:\n        total = Storage.get_size_from_path(\"/\")\n        return jsonify({\n            'total_bytes': total.convert_to_bytes(),\n            'total_readable': str(total.auto_scale()),\n            'status': 'success'\n        })\n    except Exception as e:\n        return jsonify({'error': str(e), 'status': 'error'}), 500\n</code></pre>"},{"location":"user-guide/#with-data-processing","title":"With Data Processing","text":"<pre><code>import pandas as pd\nfrom filesizelib import Storage, StorageUnit, FileSizeLib\n\ndef analyze_log_files(log_dir: str) -&gt; pd.DataFrame:\n    \"\"\"Analyze log files and return size information.\"\"\"\n    files_data = []\n\n    for log_file in Path(log_dir).glob(\"*.log\"):\n        size = Storage.get_size_from_path(log_file)\n        files_data.append({\n            'filename': log_file.name,\n            'size_bytes': size.convert_to_bytes(),\n            'size_mb': size.convert_to_mb().value,\n            'size_readable': str(size.auto_scale())\n        })\n\n    return pd.DataFrame(files_data)\n\n# Usage\ndf = analyze_log_files(\"/var/log\")\nprint(df.head())\n</code></pre>"},{"location":"user-guide/#with-configuration-files","title":"With Configuration Files","text":"<pre><code>import configparser\nfrom filesizelib import Storage, FileSizeLib\n\n# Read storage limits from config\nconfig = configparser.ConfigParser()\nconfig.read('app.conf')\n\n# Parse storage values from configuration\nmax_upload = Storage.parse(config.get('limits', 'max_upload_size'))\ncache_size = Storage.parse(config.get('cache', 'max_size'))\nlog_rotation = Storage.parse(config.get('logging', 'max_log_size'))\n\nprint(f\"Max upload: {max_upload}\")\nprint(f\"Cache size: {cache_size}\")\nprint(f\"Log rotation: {log_rotation}\")\n</code></pre>"},{"location":"user-guide/#tips-and-tricks","title":"\ud83d\udca1 Tips and Tricks","text":""},{"location":"user-guide/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Cache platform storage for multiple operations\nplatform_storage = Storage.get_platform_storage()\n\n# Process multiple files efficiently\ntotal_size = Storage(0, StorageUnit.BYTES)\nfor file_path in large_file_list:\n    size = platform_storage.get_size_from_path(file_path)\n    total_size += size\n</code></pre>"},{"location":"user-guide/#error-handling","title":"Error Handling","text":"<pre><code>def safe_parse_size(size_string: str, default: Storage = None) -&gt; Storage:\n    \"\"\"Safely parse size string with fallback.\"\"\"\n    try:\n        return Storage.parse(size_string)\n    except ValueError:\n        if default is not None:\n            return default\n        return Storage(0, StorageUnit.BYTES)\n\n# Usage\nuser_input = \"invalid size\"\nsize = safe_parse_size(user_input, Storage(1, StorageUnit.MB))\n</code></pre>"},{"location":"user-guide/#unit-consistency","title":"Unit Consistency","text":"<pre><code>def ensure_unit_type(storage: Storage, unit_type: str) -&gt; Storage:\n    \"\"\"Ensure storage uses specific unit type.\"\"\"\n    if unit_type == \"binary\" and not storage.unit.is_binary():\n        return storage.convert_to_gib() if storage.convert_to_bytes() &gt; 1024**3 else storage.convert_to_mib()\n    elif unit_type == \"decimal\" and not storage.unit.is_decimal():\n        return storage.convert_to_gb() if storage.convert_to_bytes() &gt; 1000**3 else storage.convert_to_mb()\n    return storage\n</code></pre>"},{"location":"user-guide/#whats-next","title":"\ud83d\udd0d What's Next?","text":"<p>Ready to dive deeper? Choose your next step:</p> <ul> <li> <p> Best Practices</p> <p>Learn recommended patterns and coding practices</p> </li> <li> <p> Examples</p> <p>Explore real-world applications and solutions</p> </li> <li> <p> API Reference</p> <p>Complete API documentation and reference</p> </li> </ul> <p>All examples in this guide are tested and ready to use. Copy them into your Python environment and start experimenting!</p>"},{"location":"user-guide/best-practices/","title":"Best Practices","text":"<p>Guidelines and recommendations for using Bytesize effectively in production applications.</p>"},{"location":"user-guide/best-practices/#core-principles","title":"\ud83c\udfaf Core Principles","text":""},{"location":"user-guide/best-practices/#1-choose-the-right-unit-type","title":"1. Choose the Right Unit Type","text":"<p>Binary Units for system resources and file systems: <pre><code># \u2705 Good - Binary units for memory\nram = Storage(16, StorageUnit.GIB)\ncache_size = Storage(512, StorageUnit.MIB)\n\n# \u2705 Good - Binary units for file operations\nfile_size = Storage.get_size_from_path(\"large_file.bin\")\nif file_size.convert_to_gib().value &gt; 4:\n    print(\"Large file detected\")\n</code></pre></p> <p>Decimal Units for user-facing displays and storage devices: <pre><code># \u2705 Good - Decimal units for storage devices\ndisk_capacity = Storage(500, StorageUnit.GB)\navailable_space = Storage(234.5, StorageUnit.GB)\n\n# \u2705 Good - Decimal units for download sizes\ndownload_size = Storage.parse(\"1.2 GB\")\n</code></pre></p> <p>Bit Units for network and bandwidth: <pre><code># \u2705 Good - Bit units for network speeds\nconnection_speed = Storage(100, StorageUnit.MEGABITS)\nthroughput = Storage(1, StorageUnit.GIGABITS)\n</code></pre></p>"},{"location":"user-guide/best-practices/#2-consistent-error-handling","title":"2. Consistent Error Handling","text":"<p>Always handle potential exceptions:</p> <pre><code># \u2705 Good - Comprehensive error handling\ndef get_directory_size(path: str) -&gt; Optional[Storage]:\n    \"\"\"Get directory size with proper error handling.\"\"\"\n    try:\n        return Storage.get_size_from_path(path)\n    except FileNotFoundError:\n        logging.warning(f\"Directory not found: {path}\")\n        return None\n    except PermissionError:\n        logging.warning(f\"Permission denied: {path}\")\n        return None\n    except OSError as e:\n        logging.error(f\"OS error for {path}: {e}\")\n        return None\n\n# \u2705 Good - Safe parsing with validation\ndef parse_user_input(size_string: str) -&gt; Storage:\n    \"\"\"Parse user input with validation.\"\"\"\n    if not size_string.strip():\n        raise ValueError(\"Size string cannot be empty\")\n\n    try:\n        storage = Storage.parse(size_string)\n        if storage.convert_to_bytes() &lt; 0:\n            raise ValueError(\"Size cannot be negative\")\n        return storage\n    except ValueError as e:\n        raise ValueError(f\"Invalid size format '{size_string}': {e}\")\n</code></pre>"},{"location":"user-guide/best-practices/#3-use-auto-scaling-for-display","title":"3. Use Auto-Scaling for Display","text":"<p>Always use <code>auto_scale()</code> for human-readable output:</p> <pre><code># \u2705 Good - Auto-scaling for display\ndef display_file_info(file_path: str):\n    \"\"\"Display file information in readable format.\"\"\"\n    size = Storage.get_size_from_path(file_path)\n    print(f\"File: {file_path}\")\n    print(f\"Size: {size.auto_scale()}\")  # Automatically chooses best unit\n\n# \u274c Bad - Fixed unit might be inappropriate\ndef bad_display(file_path: str):\n    size = Storage.get_size_from_path(file_path)\n    print(f\"Size: {size.convert_to_mb()}\")  # Always MB, even for KB files\n</code></pre>"},{"location":"user-guide/best-practices/#error-handling-patterns","title":"\ud83d\udee1\ufe0f Error Handling Patterns","text":""},{"location":"user-guide/best-practices/#defensive-programming","title":"Defensive Programming","text":"<pre><code>class SafeStorageCalculator:\n    \"\"\"Calculator with defensive programming practices.\"\"\"\n\n    @staticmethod\n    def safe_addition(*storages: Storage) -&gt; Storage:\n        \"\"\"Add storages with overflow protection.\"\"\"\n        if not storages:\n            return Storage(0, StorageUnit.BYTES)\n\n        total = Storage(0, StorageUnit.BYTES)\n        for storage in storages:\n            if not isinstance(storage, Storage):\n                raise TypeError(f\"Expected Storage, got {type(storage)}\")\n            total += storage\n\n        return total\n\n    @staticmethod\n    def safe_division(dividend: Storage, divisor: Union[Storage, float]) -&gt; float:\n        \"\"\"Divide with zero-division protection.\"\"\"\n        if isinstance(divisor, Storage):\n            divisor_value = divisor.convert_to_bytes()\n        else:\n            divisor_value = float(divisor)\n\n        if divisor_value == 0:\n            raise ZeroDivisionError(\"Cannot divide by zero\")\n\n        return dividend.convert_to_bytes() / divisor_value\n\n    @staticmethod\n    def validate_storage_range(\n        storage: Storage, \n        min_size: Storage, \n        max_size: Storage\n    ) -&gt; bool:\n        \"\"\"Validate storage is within acceptable range.\"\"\"\n        if min_size &gt; max_size:\n            raise ValueError(\"min_size cannot be greater than max_size\")\n\n        return min_size &lt;= storage &lt;= max_size\n</code></pre>"},{"location":"user-guide/best-practices/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>def get_disk_usage(path: str) -&gt; Dict[str, Optional[Storage]]:\n    \"\"\"Get disk usage with graceful degradation.\"\"\"\n    result = {\n        'total': None,\n        'used': None,\n        'free': None,\n        'error': None\n    }\n\n    try:\n        # Try platform-optimized approach first\n        platform_storage = Storage.get_platform_storage()\n        total = platform_storage.get_size_from_path(path)\n        result['total'] = total\n\n        # Calculate other metrics if possible\n        # ... additional logic\n\n    except Exception as e:\n        result['error'] = str(e)\n        logging.warning(f\"Could not get disk usage for {path}: {e}\")\n\n        # Fallback to basic approach\n        try:\n            import shutil\n            total, used, free = shutil.disk_usage(path)\n            result['total'] = Storage.parse_from_bytes(total)\n            result['used'] = Storage.parse_from_bytes(used)\n            result['free'] = Storage.parse_from_bytes(free)\n        except Exception as fallback_error:\n            result['error'] = f\"Primary: {e}, Fallback: {fallback_error}\"\n\n    return result\n</code></pre>"},{"location":"user-guide/best-practices/#performance-optimization","title":"\ud83c\udfaf Performance Optimization","text":""},{"location":"user-guide/best-practices/#efficient-file-operations","title":"Efficient File Operations","text":"<pre><code>class EfficientFileAnalyzer:\n    \"\"\"File analyzer optimized for performance.\"\"\"\n\n    def __init__(self):\n        # Cache platform storage instance\n        self.platform_storage = Storage.get_platform_storage()\n        self._size_cache = {}\n\n    def analyze_directory_tree(self, root_path: str, use_cache: bool = True) -&gt; Dict[str, Any]:\n        \"\"\"Analyze directory tree efficiently.\"\"\"\n        results = {\n            'total_size': Storage(0, StorageUnit.BYTES),\n            'file_count': 0,\n            'directory_count': 0,\n            'file_sizes': []\n        }\n\n        for item_path in Path(root_path).rglob('*'):\n            if item_path.is_file():\n                # Use cache if enabled\n                cache_key = str(item_path.absolute())\n                if use_cache and cache_key in self._size_cache:\n                    size = self._size_cache[cache_key]\n                else:\n                    size = self.platform_storage.get_size_from_path(item_path)\n                    if use_cache:\n                        self._size_cache[cache_key] = size\n\n                results['total_size'] += size\n                results['file_count'] += 1\n                results['file_sizes'].append(size)\n\n            elif item_path.is_dir():\n                results['directory_count'] += 1\n\n        return results\n\n    def clear_cache(self):\n        \"\"\"Clear the size cache.\"\"\"\n        self._size_cache.clear()\n</code></pre>"},{"location":"user-guide/best-practices/#batch-operations","title":"Batch Operations","text":"<pre><code>def process_files_efficiently(file_paths: List[str]) -&gt; Dict[str, Storage]:\n    \"\"\"Process multiple files efficiently.\"\"\"\n    # Use single platform storage instance\n    platform_storage = Storage.get_platform_storage()\n\n    # Process in batches to manage memory\n    batch_size = 1000\n    results = {}\n\n    for i in range(0, len(file_paths), batch_size):\n        batch = file_paths[i:i + batch_size]\n\n        for file_path in batch:\n            try:\n                size = platform_storage.get_size_from_path(file_path)\n                results[file_path] = size\n            except (FileNotFoundError, PermissionError):\n                # Skip inaccessible files\n                continue\n\n    return results\n</code></pre>"},{"location":"user-guide/best-practices/#memory-efficient-operations","title":"Memory-Efficient Operations","text":"<pre><code>def calculate_large_directory_size(directory: str) -&gt; Storage:\n    \"\"\"Calculate directory size without loading all paths into memory.\"\"\"\n    total_size = Storage(0, StorageUnit.BYTES)\n    platform_storage = Storage.get_platform_storage()\n\n    # Generator-based approach for memory efficiency\n    def file_generator():\n        for item_path in Path(directory).rglob('*'):\n            if item_path.is_file():\n                yield item_path\n\n    # Process files one at a time\n    for file_path in file_generator():\n        try:\n            size = platform_storage.get_size_from_path(file_path)\n            total_size += size\n        except (FileNotFoundError, PermissionError):\n            continue  # Skip inaccessible files\n\n    return total_size\n</code></pre>"},{"location":"user-guide/best-practices/#configuration-management","title":"\ud83d\udd27 Configuration Management","text":""},{"location":"user-guide/best-practices/#application-settings","title":"Application Settings","text":"<pre><code>from dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass StorageSettings:\n    \"\"\"Application storage settings.\"\"\"\n    default_unit_type: str = \"binary\"  # \"binary\", \"decimal\", \"bits\"\n    display_precision: int = 2\n    max_file_size: Storage = Storage(100, StorageUnit.MB)\n    cache_enabled: bool = True\n    platform_optimizations: bool = True\n\n    def __post_init__(self):\n        \"\"\"Validate settings after initialization.\"\"\"\n        valid_unit_types = {\"binary\", \"decimal\", \"bits\"}\n        if self.default_unit_type not in valid_unit_types:\n            raise ValueError(f\"Invalid unit type: {self.default_unit_type}\")\n\n        if self.display_precision &lt; 0:\n            raise ValueError(\"Display precision cannot be negative\")\n\nclass StorageManager:\n    \"\"\"Centralized storage management with configuration.\"\"\"\n\n    def __init__(self, settings: Optional[StorageSettings] = None):\n        self.settings = settings or StorageSettings()\n        self._platform_storage = None\n\n    @property\n    def platform_storage(self):\n        \"\"\"Lazy-loaded platform storage.\"\"\"\n        if self._platform_storage is None:\n            if self.settings.platform_optimizations:\n                self._platform_storage = Storage.get_platform_storage()\n            else:\n                # Use basic storage implementation\n                from bytesize.platform_storage import DefaultPlatformStorage\n                self._platform_storage = DefaultPlatformStorage()\n        return self._platform_storage\n\n    def format_size(self, storage: Storage) -&gt; str:\n        \"\"\"Format size according to settings.\"\"\"\n        scaled = storage.auto_scale(\n            prefer_binary=(self.settings.default_unit_type == \"binary\")\n        )\n        return f\"{scaled.value:.{self.settings.display_precision}f} {scaled.unit.name}\"\n\n    def validate_file_size(self, file_path: str) -&gt; bool:\n        \"\"\"Validate file size against settings.\"\"\"\n        try:\n            file_size = self.platform_storage.get_size_from_path(file_path)\n            return file_size &lt;= self.settings.max_file_size\n        except (FileNotFoundError, PermissionError):\n            return False\n</code></pre>"},{"location":"user-guide/best-practices/#logging-and-monitoring","title":"\ud83d\udcca Logging and Monitoring","text":""},{"location":"user-guide/best-practices/#structured-logging","title":"Structured Logging","text":"<pre><code>import logging\nimport json\nfrom datetime import datetime\n\nclass StorageLogger:\n    \"\"\"Structured logging for storage operations.\"\"\"\n\n    def __init__(self, logger_name: str = \"bytesize\"):\n        self.logger = logging.getLogger(logger_name)\n\n    def log_file_operation(self, operation: str, file_path: str, \n                          size: Optional[Storage] = None, \n                          duration: Optional[float] = None,\n                          error: Optional[str] = None):\n        \"\"\"Log file operation with structured data.\"\"\"\n        log_data = {\n            'timestamp': datetime.utcnow().isoformat(),\n            'operation': operation,\n            'file_path': file_path,\n            'size_bytes': size.convert_to_bytes() if size else None,\n            'size_readable': str(size.auto_scale()) if size else None,\n            'duration_seconds': duration,\n            'error': error,\n            'success': error is None\n        }\n\n        if error:\n            self.logger.error(f\"Storage operation failed: {json.dumps(log_data)}\")\n        else:\n            self.logger.info(f\"Storage operation completed: {json.dumps(log_data)}\")\n\n    def log_performance_metrics(self, operation: str, file_count: int, \n                               total_size: Storage, duration: float):\n        \"\"\"Log performance metrics.\"\"\"\n        metrics = {\n            'timestamp': datetime.utcnow().isoformat(),\n            'operation': operation,\n            'file_count': file_count,\n            'total_size_bytes': total_size.convert_to_bytes(),\n            'total_size_readable': str(total_size.auto_scale()),\n            'duration_seconds': duration,\n            'files_per_second': file_count / duration if duration &gt; 0 else 0,\n            'bytes_per_second': total_size.convert_to_bytes() / duration if duration &gt; 0 else 0\n        }\n\n        self.logger.info(f\"Performance metrics: {json.dumps(metrics)}\")\n\n# Usage example\ndef monitored_file_scan(directory: str) -&gt; Dict[str, Any]:\n    \"\"\"File scan with comprehensive monitoring.\"\"\"\n    logger = StorageLogger()\n    start_time = time.time()\n\n    try:\n        total_size = Storage(0, StorageUnit.BYTES)\n        file_count = 0\n\n        for file_path in Path(directory).rglob('*'):\n            if file_path.is_file():\n                operation_start = time.time()\n                try:\n                    size = Storage.get_size_from_path(file_path)\n                    total_size += size\n                    file_count += 1\n\n                    operation_duration = time.time() - operation_start\n                    logger.log_file_operation(\n                        'scan', str(file_path), size, operation_duration\n                    )\n\n                except Exception as e:\n                    operation_duration = time.time() - operation_start\n                    logger.log_file_operation(\n                        'scan', str(file_path), None, operation_duration, str(e)\n                    )\n\n        total_duration = time.time() - start_time\n        logger.log_performance_metrics(\n            'directory_scan', file_count, total_size, total_duration\n        )\n\n        return {\n            'total_size': total_size,\n            'file_count': file_count,\n            'duration': total_duration\n        }\n\n    except Exception as e:\n        logger.logger.error(f\"Directory scan failed: {e}\")\n        raise\n</code></pre>"},{"location":"user-guide/best-practices/#testing-best-practices","title":"\ud83e\uddea Testing Best Practices","text":""},{"location":"user-guide/best-practices/#comprehensive-test-coverage","title":"Comprehensive Test Coverage","text":"<pre><code>import unittest\nimport tempfile\nimport os\nfrom pathlib import Path\n\nclass TestStorageOperations(unittest.TestCase):\n    \"\"\"Comprehensive storage operation tests.\"\"\"\n\n    def setUp(self):\n        \"\"\"Set up test environment.\"\"\"\n        self.temp_dir = tempfile.mkdtemp()\n        self.test_files = []\n\n        # Create test files of various sizes\n        sizes = [100, 1024, 1048576, 10485760]  # 100B, 1KB, 1MB, 10MB\n        for i, size in enumerate(sizes):\n            file_path = Path(self.temp_dir) / f\"test_file_{i}.bin\"\n            with open(file_path, 'wb') as f:\n                f.write(b'0' * size)\n            self.test_files.append(file_path)\n\n    def tearDown(self):\n        \"\"\"Clean up test environment.\"\"\"\n        import shutil\n        shutil.rmtree(self.temp_dir)\n\n    def test_file_size_accuracy(self):\n        \"\"\"Test that file sizes are reported accurately.\"\"\"\n        expected_sizes = [100, 1024, 1048576, 10485760]\n\n        for file_path, expected_size in zip(self.test_files, expected_sizes):\n            with self.subTest(file=file_path, expected=expected_size):\n                storage = Storage.get_size_from_path(file_path)\n                self.assertEqual(storage.convert_to_bytes(), expected_size)\n\n    def test_error_handling(self):\n        \"\"\"Test error handling for various scenarios.\"\"\"\n        # Non-existent file\n        with self.assertRaises(FileNotFoundError):\n            Storage.get_size_from_path(\"nonexistent_file.txt\")\n\n        # Invalid parsing\n        with self.assertRaises(ValueError):\n            Storage.parse(\"invalid size\")\n\n        # Negative values\n        with self.assertRaises(ValueError):\n            Storage(-1, StorageUnit.BYTES)\n\n    def test_arithmetic_operations(self):\n        \"\"\"Test arithmetic operations comprehensively.\"\"\"\n        storage1 = Storage(1, StorageUnit.GB)\n        storage2 = Storage(500, StorageUnit.MB)\n\n        # Addition\n        result = storage1 + storage2\n        self.assertAlmostEqual(result.convert_to_gb().value, 1.5, places=6)\n\n        # Subtraction\n        result = storage1 - storage2\n        self.assertAlmostEqual(result.convert_to_mb().value, 500, places=6)\n\n        # Multiplication\n        result = storage1 * 2\n        self.assertEqual(result.convert_to_gb().value, 2.0)\n\n        # Division\n        ratio = storage1 / storage2\n        self.assertEqual(ratio, 2.0)\n\n    def test_conversion_accuracy(self):\n        \"\"\"Test conversion accuracy between units.\"\"\"\n        # Test binary conversions\n        storage = Storage(1, StorageUnit.GIB)\n        self.assertEqual(storage.convert_to_mib().value, 1024.0)\n        self.assertEqual(storage.convert_to_kib().value, 1048576.0)\n\n        # Test decimal conversions\n        storage = Storage(1, StorageUnit.GB)\n        self.assertEqual(storage.convert_to_mb().value, 1000.0)\n        self.assertEqual(storage.convert_to_kb().value, 1000000.0)\n\n        # Test bit conversions\n        storage = Storage(1, StorageUnit.BYTES)\n        self.assertEqual(storage.convert_to_bits().value, 8.0)\n\n# Performance benchmarks\nclass StoragePerformanceTests(unittest.TestCase):\n    \"\"\"Performance-focused tests.\"\"\"\n\n    def test_large_file_performance(self):\n        \"\"\"Test performance with large files.\"\"\"\n        import time\n\n        with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n            # Write 100MB file\n            temp_file.write(b'0' * (100 * 1024 * 1024))\n            temp_file.flush()\n\n            # Measure performance\n            start_time = time.time()\n            size = Storage.get_size_from_path(temp_file.name)\n            duration = time.time() - start_time\n\n            # Should complete in reasonable time (&lt; 1 second)\n            self.assertLess(duration, 1.0)\n            self.assertEqual(size.convert_to_mb().value, 100.0)\n\n            os.unlink(temp_file.name)\n</code></pre>"},{"location":"user-guide/best-practices/#code-quality-guidelines","title":"\ud83d\udcc8 Code Quality Guidelines","text":""},{"location":"user-guide/best-practices/#type-hints-and-documentation","title":"Type Hints and Documentation","text":"<pre><code>from typing import List, Optional, Union, Dict, Any\nfrom pathlib import Path\n\ndef analyze_storage_distribution(\n    file_paths: List[Union[str, Path]],\n    size_ranges: Optional[Dict[str, tuple]] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Analyze the distribution of file sizes across specified ranges.\n\n    Args:\n        file_paths: List of file paths to analyze\n        size_ranges: Optional dict mapping range names to (min, max) tuples\n                    in bytes. If None, uses default ranges.\n\n    Returns:\n        Dict containing:\n        - 'distribution': Dict mapping range names to file counts\n        - 'total_files': Total number of files processed\n        - 'total_size': Total size of all files\n        - 'average_size': Average file size\n        - 'largest_file': Path and size of largest file\n        - 'smallest_file': Path and size of smallest file\n\n    Raises:\n        ValueError: If size_ranges contains invalid ranges\n        FileNotFoundError: If any file in file_paths doesn't exist\n\n    Example:\n        &gt;&gt;&gt; files = ['file1.txt', 'file2.bin']\n        &gt;&gt;&gt; ranges = {'small': (0, 1024), 'large': (1024, float('inf'))}\n        &gt;&gt;&gt; result = analyze_storage_distribution(files, ranges)\n        &gt;&gt;&gt; print(result['distribution'])\n        {'small': 1, 'large': 1}\n    \"\"\"\n    if size_ranges is None:\n        size_ranges = {\n            'tiny': (0, 1024),                    # 0-1KB\n            'small': (1024, 1024**2),            # 1KB-1MB\n            'medium': (1024**2, 1024**3),        # 1MB-1GB\n            'large': (1024**3, float('inf'))     # 1GB+\n        }\n\n    # Validate size ranges\n    for name, (min_size, max_size) in size_ranges.items():\n        if min_size &lt; 0 or max_size &lt;= min_size:\n            raise ValueError(f\"Invalid range '{name}': {min_size}-{max_size}\")\n\n    distribution = {name: 0 for name in size_ranges.keys()}\n    file_sizes = []\n    largest_file = None\n    smallest_file = None\n\n    for file_path in file_paths:\n        size = Storage.get_size_from_path(file_path)\n        size_bytes = size.convert_to_bytes()\n        file_sizes.append((file_path, size))\n\n        # Update largest/smallest tracking\n        if largest_file is None or size &gt; largest_file[1]:\n            largest_file = (file_path, size)\n        if smallest_file is None or size &lt; smallest_file[1]:\n            smallest_file = (file_path, size)\n\n        # Categorize by size range\n        for range_name, (min_size, max_size) in size_ranges.items():\n            if min_size &lt;= size_bytes &lt; max_size:\n                distribution[range_name] += 1\n                break\n\n    total_size = sum(size for _, size in file_sizes)\n    average_size = total_size / len(file_sizes) if file_sizes else Storage(0, StorageUnit.BYTES)\n\n    return {\n        'distribution': distribution,\n        'total_files': len(file_sizes),\n        'total_size': total_size,\n        'average_size': average_size,\n        'largest_file': largest_file,\n        'smallest_file': smallest_file\n    }\n</code></pre> <p>These best practices will help you build robust, maintainable applications with Bytesize. Remember to adapt them to your specific use case and requirements.</p> <p> Back to User Guide  Examples</p>"}]}